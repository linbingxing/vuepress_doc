---
title: Spring Cloud Netfix核心组件
date: 2022-01-01 18:44:12
permalink: /pages/02c589/
categories:
  - 框架
  - Spring Cloud
tags:
  - 
---
#  第四部分 Spring Cloud Netflix核心组件

## 第1节 Eureka 服务注册中心

### 1.1  关于服务注册中心

**注意：服务注册中⼼本质上是为了解耦服务提供者和服务消费者。**

对于任何⼀个微服务，原则上都应存在或者支持多个提供者（比如用户微服务部署多个实例），这是由微服务的**分布式属性**决定的。更进⼀步，为了支持弹性扩缩容特性，⼀个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态LB机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。

#### **1.1.1** **服务注册中心⼀般原理**

![cloud-register](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-register.png)

分布式微服务架构中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不再需要通过硬编码方式得到提供者的地址信息。消费者只需要知道当前系统发布了那些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。

1）服务提供者启动

2）服务提供者将相关服务信息主动注册到注册中心

3）服务消费者获取服务注册信息：

- pull模式：服务消费者可以主动拉取可⽤的服务提供者清单
- push模式：服务消费者订阅服务（当服务提供者有变化时，注册中心也会主动推送更新后的服务清单给消费者

4）服务消费者直接调用服务提供者

另外，注册中心也需要完成服务提供者的健康监控，当发现服务提供者失效时需要及时剔除；

####  **1.1.2** **主流服务中心对⽐**

##### **Zookeeper**

Zookeeper它是⼀个分布式服务框架，是Apache Hadoop 的⼀个⼦项⽬，它主要是⽤来解决分布式应 ⽤中经常遇到的⼀些数据管理问题，如：统⼀命名服务、状态同步服务、集群管理、分布式应⽤配置项的管理等。

简单来说zookeeper本质=存储+监听通知。

Zookeeper ⽤来做服务注册中⼼，主要是因为它具有节点变更通知功能，只要客户端监听相关服务节点，服务节点的所有变更，都能及时的通知到监听客户端，这样作为调⽤⽅只要使用Zookeeper 的客户端就能实现服务节点的订阅和变更通知功能了，⾮常⽅便。另外，Zookeeper 可⽤性也可以，因为只要半数以上的选举节点存活，整个集群就是可⽤的。

##### Eureka

由Netflix开源，并被Pivatal集成到Spring Cloud体系中，它是基于RestfulAPI风格开发的服务注册与发现组件。

#####  Consul

Consul是由HashiCorp基于Go语⾔开发的⽀持多数据中⼼分布式⾼可⽤的服务发布和注册服务软件， 采⽤Raft算法保证服务的⼀致性，且⽀持健康检查。

#####  Nacos

Nacos是⼀个更易于构建云原⽣应⽤的动态服务发现、配置管理和服务管理平台。简单来说 Nacos 就是 注册中⼼ + 配置中⼼的组合，帮助我们解决微服务开发必会涉及到的服务注册 与发现，服务配置，服务管理等问题。Nacos 是Spring Cloud Alibaba 核⼼组件之⼀，负责服务注册与发现，还有配置。

| 组件名    | 语言 | CAP           | 对外暴露接口 |
| --------- | ---- | ------------- | ------------ |
| Eureka    | Java | AP            | HTTP         |
| Consul    | Go   | CP            | HTTP/DNS     |
| Zookeeper | Java | CP            | 客户端       |
| Nacos     | Java | 支持AP/CP切换 | HTTP         |

### **1.2** **服务注册中⼼组件** **Eureka**

#### 1.2.1 Eureka 基础架构

![cloud-eureka](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka.png)

#### 1.2.2 Eureka 交互流程及原理

![cloud-eureka1](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka1.png)

Eureka 包含两个组件：Eureka Server 和 Eureka Client。

Eureka Client是⼀个Java客户端，⽤于简化与Eureka Server的交互；

Eureka Server提供服务发现的能⼒，各个微服务启动时，会通过Eureka Client向Eureka Server 进⾏注册⾃⼰

的信息（例如⽹络信息），Eureka Server会存储该服务的信息；

1）图中us-east-1c、us-east-1d，us-east-1e代表不同的区也就是不同的机房2）图中每⼀个Eureka Server都是⼀个集群。

3）图中Application Service作为服务提供者向Eureka Server中注册服务，Eureka Server接受到注册事件会在集群和分区中进⾏数据同步，Application Client作为消费端（服务消费者）可以从Eureka Server中获取到服务注册信息，进⾏服务调⽤。

4）微服务启动后，会周期性地向Eureka Server发送⼼跳（默认周期为30秒）以续约⾃⼰的信息

5）Eureka Server在⼀定时间内没有接收到某个微服务节点的⼼跳，Eureka Server将会注销该微服务节点（默认90秒）

6）每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过复制的⽅式完成服务注册列表的同步

7）Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使⽤缓存中的信息找到服务提供者

**Eureka通过⼼跳检测、健康检查和客户端缓存等机制，提⾼系统的灵活性、可**

**伸缩性和可⽤性。**

### 1.3 Eureka应⽤及⾼可⽤集群

1）单实例Eureka Server—>访问管理界⾯—>Eureka Server集群

2）服务提供者（简历微服务注册到集群）

3）服务消费者（⾃动投递微服务注册到集群/从Eureka Server集群获取服务信息）

4）完成调⽤

#### **1.3.1** 搭建单例Eureka Server服务注册中⼼

基于Maven构建SpringBoot⼯程，在SpringBoot⼯程之上搭建EurekaServer服务。

- learn-parent中引⼊Spring Cloud 依赖

```xml
<dependencyManagement>
 <dependencies>
 	<dependency>
 		<groupId>org.springframework.cloud</groupId>
 		<artifactId>spring-cloud-dependencies</artifactId>
 		<version>Greenwich.RELEASE</version>
 		<type>pom</type>
 		<scope>import</scope>
 	</dependency>
 </dependencies>
</dependencyManagement>
```

- 当前⼯程pom.xml中引⼊依赖

```xml
<dependencies>
     <!--Eureka server依赖-->
     <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-netflix-eurekaserver</artifactId>
     </dependency>
</dependencies>
```

**注意：在⽗⼯程的pom⽂件中⼿动引⼊jaxb的jar，因为Jdk9之后默认没有加载该模块，EurekaServer使⽤到，所以需要⼿动导⼊，否则EurekaServer服务⽆法启动.**

⽗⼯程pom.xml

```xml
 <!--eureka server 需要引入Jaxb，开始-->
        <dependency>
            <groupId>com.sun.xml.bind</groupId>
            <artifactId>jaxb-core</artifactId>
            <version>2.2.11</version>
        </dependency>
        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
        </dependency>
        <dependency>
            <groupId>com.sun.xml.bind</groupId>
            <artifactId>jaxb-impl</artifactId>
            <version>2.2.11</version>
        </dependency>
        <dependency>
            <groupId>org.glassfish.jaxb</groupId>
            <artifactId>jaxb-runtime</artifactId>
            <version>2.2.10-b140310.1920</version>
        </dependency>
        <dependency>
            <groupId>javax.activation</groupId>
            <artifactId>activation</artifactId>
            <version>1.1.1</version>
        </dependency>
        <!--引入Jaxb，结束-->
```

- application.yml

```yaml
#eureka server服务端口
server:
  port: 8761
spring:
  application:
    name: learn-cloud-eureka-server # 应用名称，应用名称会在Eureka中作为服务名称

    # eureka 客户端配置（和Server交互），Eureka Server 其实也是一个Client
eureka:
  instance:
    hostname: localhost  # 当前eureka实例的主机名
  client:
    service-url:
      # 配置客户端所交互的Eureka Server的地址（Eureka Server集群中每一个Server其实相对于其它Server来说都是Client）
      # 集群模式下，defaultZone应该指向其它Eureka Server，如果有更多其它Server实例，逗号拼接即可
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka
    register-with-eureka: false  # 集群模式下可以改成true
    fetch-registry: false # 集群模式下可以改成true
  dashboard:
    enabled: true
```

- SpringBoot启动类，使⽤@EnableEurekaServer声明当前项⽬为EurekaServer服务

```java
@SpringBootApplication
// 声明当前项目为Eureka服务
@EnableEurekaServer
public class EurekaServerApp8761 {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApp8761.class,args);
    }

}
```

- 执⾏启动类EurekaServerApp8761的main函数
- 访问http://127.0.0.1:8761，如果看到如下⻚⾯（Eureka注册中⼼后台），则表明EurekaServer发布成功

![cloud-eureka2](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka2.png)

#### **1.3.2** 搭建Eureka Server HA⾼可⽤集群

在互联⽹应⽤中，服务实例很少有单个的。即使微服务消费者会缓存服务列表，但是如果EurekaServer只有⼀个实例，该实例挂掉，正好微服务消费者本地缓存列表中的服务实例也不可⽤，那么这个时候整个系统都受影响。

在⽣产环境中，我们会配置Eureka Server集群实现⾼可⽤。Eureka Server集群之中的节点通过点对点（P2P）通信的⽅式共享服务注册表。我们开启两台 Eureka Server 以搭建集群。

![cloud-eureka3](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka3.png)

修改yarm配置文件

```yaml
#eureka server服务端口
server:
  port: 8761
spring:
  application:
    name: learn-cloud-eureka-server # 应用名称，应用名称会在Eureka中作为服务名称

    # eureka 客户端配置（和Server交互），Eureka Server 其实也是一个Client
eureka:
  instance:
    hostname: localhost  # 当前eureka实例的主机名
  client:
    service-url:
      # 配置客户端所交互的Eureka Server的地址（Eureka Server集群中每一个Server其实相对于其它Server来说都是Client）
      # 集群模式下，defaultZone应该指向其它Eureka Server，如果有更多其它Server实例，逗号拼接即可
      defaultZone: http://${eureka.instance.hostname}:8762/eureka
    register-with-eureka: true  # 集群模式下可以改成true
    fetch-registry: true # 集群模式下可以改成true
  dashboard:
    enabled: true
    

#eureka server服务端口
server:
  port: 8762
spring:
  application:
    name: learn-cloud-eureka-server # 应用名称，应用名称会在Eureka中作为服务名称

    # eureka 客户端配置（和Server交互），Eureka Server 其实也是一个Client
eureka:
  instance:
    hostname: localhost  # 当前eureka实例的主机名
  client:
    service-url:
      # 配置客户端所交互的Eureka Server的地址（Eureka Server集群中每一个Server其实相对于其它Server来说都是Client）
      # 集群模式下，defaultZone应该指向其它Eureka Server，如果有更多其它Server实例，逗号拼接即可
      defaultZone: http://${eureka.instance.hostname}:8761/eureka
    register-with-eureka: true  # 集群模式下可以改成true
    fetch-registry: true # 集群模式下可以改成true
  dashboard:
    enabled: true
```

### 1.4 Eureka细节详解

#### 1.4.1 Eureka元数据详解

Eureka的元数据有两种：标准元数据和自定义元数据。

**标准元数据**：主机名、IP地址、端口号等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。

**自定义元数据**：可以使用eureka.instance.metadata-map配置，符合KEY/VALUE的存储格式。这 些元数据可以在远程客户端中访问。比如如下示例

```yaml
instance:
 prefer-ip-address: true
 metadata-map:
 # ⾃定义元数据(kv⾃定义)
 cluster: cl1
 region: rn1
```

我们可以在程序中可以使用DiscoveryClient 获取指定微服务的所有元数据信息。

```java
@SpringBootTest(classes = {UserApplication.class})
@RunWith(SpringJUnit4ClassRunner.class)
public class AutodeliverApplicationTest {

    @Autowired
    private DiscoveryClient discoveryClient;

    @Test
    public void test() {
        // 从EurekaServer获取指定微服务实例
        List<ServiceInstance> serviceInstanceList =
                discoveryClient.getInstances("learn-service-user");
        // 循环打印每个微服务实例的元数据信息
        for (int i = 0; i < serviceInstanceList.size(); i++) {
            ServiceInstance serviceInstance =
                    serviceInstanceList.get(i);
            System.out.println(serviceInstance);
        }
    }
}
```

元数据查看如下:

![cloud-eureka4](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka4.png)

#### 1.4.2 Eureka客户端详解

服务提供者（也是Eureka客户端）要向EurekaServer注册服务，并完成服务续约等⼯作

**服务注册详解（服务提供者）**

1）当我们导⼊了eureka-client依赖坐标，配置Eureka服务注册中⼼地址

2）服务在启动时会向注册中⼼发起注册请求，携带服务元数据信息

3）Eureka注册中⼼会把服务的信息保存在Map中。**服务续约详解（服务提供者）**

服务每隔30秒会向注册中⼼续约(⼼跳)⼀次（也称为报活），如果没有续约，租约在

90秒后到期，然后服务会被失效。每隔30秒的续约操作我们称之为⼼跳检测

往往不需要我们调整这两个配置

```yaml
#向Eureka服务中⼼集群注册服务
eureka:
 instance:
 # 租约续约间隔时间，默认30秒
 lease-renewal-interval-in-seconds: 30
 # 租约到期，服务时效时间，默认值90秒,服务超过90秒没有发⽣⼼跳，
EurekaServer会将服务从列表移除
 lease-expiration-duration-in-seconds: 90
```

**获取服务列表详解（服务消费者）**

每隔30秒服务会从注册中⼼中拉取⼀份服务列表，这个时间可以通过配置修改。往

往不需要我们调整

```yaml
#向Eureka服务中⼼集群注册服务
eureka:
 client:
 # 每隔多久拉取⼀次服务列表
 registry-fetch-interval-seconds: 30
```

1）服务消费者启动时，从 EurekaServer服务列表获取只读备份，缓存到本地

2）每隔30秒，会重新获取并更新数据

3）每隔30秒的时间可以通过配置eureka.client.registry-fetch-interval-seconds修改

#### **1.4.3 Eureka服务端详解**

**服务下线**

1）当服务正常关闭操作时，会发送服务下线的REST请求给EurekaServer。 

2）服务中⼼接受到请求后，将该服务置为下线状态

**失效剔除**

Eureka Server会定时（间隔值是eureka.server.eviction-interval-timer-in-ms，默认60s）进⾏检查，如果发现实例在在⼀定时间（此值由客户端设置的eureka.instance.lease-expiration-duration-in-seconds定义，默认值为90s）内没有收到⼼跳，则会注销此实例。

**自我保护**

服务提供者 —> 注册中心

定期的续约（服务提供者和注册中心通信），假如服务提供者和注册中心之间的网络有点问题，不代表服务提供者不可用，不代表服务消费者⽆法访问服务提供者如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中⼼出现了⽹络故障，Eureka Server自动进⼊自我保护机制。

为什么会有自我保护机制？

默认情况下，如果Eureka Server在⼀定时间内（默认90秒）没有接收到某个微服务实例的⼼跳，Eureka Server将会移除该实例。但是当⽹络分区故障发⽣时，微服务与Eureka Server之间⽆法正常通信，⽽微服务本身是正常运⾏的，此时不应该移除这个微服务，所以引⼊了⾃我保护机制。

当处于自我保护模式时

1）不会剔除任何服务实例（可能是服务提供者和EurekaServer之间⽹络问题），保证了⼤多数服务依然可⽤

2）Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可⽤，当⽹络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。

3）在Eureka Server⼯程中通过eureka.server.enable-self-preservation配置可⽤关停⾃我保护，默认值是打开。

```yaml
eureka:
 server:
 enable-self-preservation: false # 关闭⾃我保护模式（缺省为打开）
```

###  1.5 Eureka核心源码剖析

#### 1.5.1 Eureka Server启动过程

⼊⼝：SpringCloud充分利⽤了SpringBoot的⾃动装配的特点

- 观察eureka-server的jar包，发现在META-INF下⾯有配置⽂件spring.factories

  ![cloud-eureka5](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka5.png)

  Springboot应⽤启动时会加载EurekaServerAutoConfifiguration⾃动配置类

- EurekaServerAutoConfifiguration类

![cloud-eureka6](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka6.png)

1. 需要有⼀个marker bean，才能装配Eureka Server，那么这个marker其实是由@EnableEurekaServer注解决定的

   ```java
   @Configuration
   public class EurekaServerMarkerConfiguration {
   
      @Bean
      public Marker eurekaServerMarkerBean() {
         return new Marker();
      }
   
      class Marker {
      }
   }
   ```

2. ```java
   //控制是否展示仪表盘
   @Bean
   @ConditionalOnProperty(prefix = "eureka.dashboard", name = "enabled", matchIfMissing = true)
   public EurekaController eurekaController() {
      return new EurekaController(this.applicationInfoManager);
   }
   
   //对等节点感知实例注册器
   //集群模式下注册服务使用到的注册器
   //EurekaServer集群中各个节点是对等的，没有主从之分
   @Bean
   public PeerAwareInstanceRegistry peerAwareInstanceRegistry(
       ServerCodecs serverCodecs) {
       this.eurekaClient.getApplications(); // force initialization
       return new InstanceRegistry(this.eurekaServerConfig, this.eurekaClientConfig,
                                   serverCodecs, this.eurekaClient,
                                   this.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(),
                                   this.instanceRegistryProperties.getDefaultOpenForTrafficCount());
   }
   
   //注入了PeerEurekaNodes,辅助封装对等节点相关的信息和操作，比如更新集群当中的对等
   @Bean
   @ConditionalOnMissingBean
   public PeerEurekaNodes peerEurekaNodes(PeerAwareInstanceRegistry registry,
                                          ServerCodecs serverCodecs) {
       return new RefreshablePeerEurekaNodes(registry, this.eurekaServerConfig,
                                             this.eurekaClientConfig, serverCodecs, this.applicationInfoManager);
   }
   ```

#### 1.5.2 Eureka Server服务接⼝暴露策略

在Eureka Server启动过程中主配置类注册了Jersey框架（是⼀个发布restful⻛格接⼝的框架，类似于我们的springmvc）

```java
/**
 * Register the Jersey filter
 * 启动时注册了Jersey框架
 */
@Bean
public FilterRegistrationBean jerseyFilterRegistration(
      javax.ws.rs.core.Application eurekaJerseyApp) {
   FilterRegistrationBean bean = new FilterRegistrationBean();
   bean.setFilter(new ServletContainer(eurekaJerseyApp));
   bean.setOrder(Ordered.LOWEST_PRECEDENCE);
   bean.setUrlPatterns(
         Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + "/*"));

   return bean;
}
```

注⼊的Jersey细节，根据指定的包，扫描Jersey注解

```java
/**
 * List of packages containing Jersey resources required by the Eureka server
 */
private static final String[] EUREKA_PACKAGES = new String[] { "com.netflix.discovery",
      "com.netflix.eureka" };
```

```java
/**
 * Construct a Jersey {@link javax.ws.rs.core.Application} with all the resources
 * required by the Eureka server.
 */
@Bean
public javax.ws.rs.core.Application jerseyApplication(Environment environment,
      ResourceLoader resourceLoader) {

   ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(
         false, environment);

   // Filter to include only classes that have a particular annotation.
   // 配置Jersey注解
   provider.addIncludeFilter(new AnnotationTypeFilter(Path.class));
   provider.addIncludeFilter(new AnnotationTypeFilter(Provider.class));

   // Find classes in Eureka packages (or subpackages)
   // EUREKA_PACKAGES = new String[] { "com.netflix.discovery",
			"com.netflix.eureka" };
   // 扫描注解---指定要扫描的包，会扫描包以及子包
   Set<Class<?>> classes = new HashSet<>();
   for (String basePackage : EUREKA_PACKAGES) {
      Set<BeanDefinition> beans = provider.findCandidateComponents(basePackage);
      for (BeanDefinition bd : beans) {
         Class<?> cls = ClassUtils.resolveClassName(bd.getBeanClassName(),
               resourceLoader.getClassLoader());
         classes.add(cls);
      }
   }

   // Construct the Jersey ResourceConfig
   //
   Map<String, Object> propsAndFeatures = new HashMap<>();
   propsAndFeatures.put(
         // Skip static content used by the webapp
         ServletContainer.PROPERTY_WEB_PAGE_CONTENT_REGEX,
         EurekaConstants.DEFAULT_PREFIX + "/(fonts|images|css|js)/.*");

   DefaultResourceConfig rc = new DefaultResourceConfig(classes);
   rc.setPropertiesAndFeatures(propsAndFeatures);

   return rc;
}
```

对外提供的接口服务，在Jersey中叫做资源，这些就是使用Jersey发布的供Eureka Client调⽤的Restful风格服务接口（完成服务注册、⼼跳续约等接口）

![cloud-eureka7](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-eureka7.png)

#### **1.5.3 Eureka Server服务注册接⼝（接受客户端注册服务）**

com.netflix.eureka.resources.**ApplicationResource**类的addInstance()，添加实例

```java
/**
 * Registers information about a particular instance for an
 * {@link com.netflix.discovery.shared.Application}.
 *
 * @param info
 *            {@link InstanceInfo} information of the instance.
 * @param isReplication
 *            a header parameter containing information whether this is
 *            replicated from other nodes.
 */
@POST
@Consumes({"application/json", "application/xml"})
public Response addInstance(InstanceInfo info,
                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
    logger.debug("Registering instance {} (replication={})", info.getId(), isReplication);
    // validate that the instanceinfo contains all the necessary required fields
    if (isBlank(info.getId())) {
        return Response.status(400).entity("Missing instanceId").build();
    } else if (isBlank(info.getHostName())) {
        return Response.status(400).entity("Missing hostname").build();
    } else if (isBlank(info.getIPAddr())) {
        return Response.status(400).entity("Missing ip address").build();
    } else if (isBlank(info.getAppName())) {
        return Response.status(400).entity("Missing appName").build();
    } else if (!appName.equals(info.getAppName())) {
        return Response.status(400).entity("Mismatched appName, expecting " + appName + " but was " + info.getAppName()).build();
    } else if (info.getDataCenterInfo() == null) {
        return Response.status(400).entity("Missing dataCenterInfo").build();
    } else if (info.getDataCenterInfo().getName() == null) {
        return Response.status(400).entity("Missing dataCenterInfo Name").build();
    }

    // handle cases where clients may be registering with bad DataCenterInfo with missing data
    DataCenterInfo dataCenterInfo = info.getDataCenterInfo();
    if (dataCenterInfo instanceof UniqueIdentifier) {
        String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();
        if (isBlank(dataCenterInfoId)) {
            boolean experimental = "true".equalsIgnoreCase(serverConfig.getExperimental("registration.validation.dataCenterInfoId"));
            if (experimental) {
                String entity = "DataCenterInfo of type " + dataCenterInfo.getClass() + " must contain a valid id";
                return Response.status(400).entity(entity).build();
            } else if (dataCenterInfo instanceof AmazonInfo) {
                AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;
                String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);
                if (effectiveId == null) {
                    amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());
                }
            } else {
                logger.warn("Registering DataCenterInfo of type {} without an appropriate id", dataCenterInfo.getClass());
            }
        }
    }
    //注册服务实例
    registry.register(info, "true".equals(isReplication));
    return Response.status(204).build();  // 204 to be backwards compatible
}
```

在com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl\#register - 注册服务信息并同步到其它Eureka节点

```java
/**
 * Registers the information about the {@link InstanceInfo} and replicates
 * this information to all peer eureka nodes. If this is replication event
 * from other replica nodes then it is not replicated.
 *
 * @param info
 *            the {@link InstanceInfo} to be registered and replicated.
 * @param isReplication
 *            true if this is a replication event from other replica nodes,
 *            false otherwise.
 */
@Override
public void register(final InstanceInfo info, final boolean isReplication) {
    int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
    //服务时效间隔，如果客户端自己配置了，取客户端配置
    if (info.getLeaseInfo() != null && info.getLeaseInfo().getDurationInSecs() > 0) {
        leaseDuration = info.getLeaseInfo().getDurationInSecs();
    }
    //调用父类register注册实例
    super.register(info, leaseDuration, isReplication);
    //同步到其他Eureka节点
    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);
}
```

AbstractInstanceRegistry#register()：注册，实例信息存储到注册表是⼀个ConcurrentHashMap

```java
/**
 * Registers a new instance with a given duration.
 *
 * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object, int, boolean)
 */
public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {
    try {
        //读锁
        read.lock();
        //registry保存所有应用实例信息的Map
        //从registry中获取当前appName的所有实例信息
        Map<String, Lease<InstanceInfo>> gMap = registry.get(registrant.getAppName());
         //注册统计+1
        REGISTER.increment(isReplication);
        // 如果当前appName实例信息为空，新建Map
        if (gMap == null) {
            final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap = new ConcurrentHashMap<String, Lease<InstanceInfo>>();
            gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);
            if (gMap == null) {
                gMap = gNewMap;
            }
        }
        // 获取实例的Lease租约信息
        Lease<InstanceInfo> existingLease = gMap.get(registrant.getId());
        // Retain the last dirty timestamp without overwriting it, if there is already a lease
         // 如果已经有租约，则保留最后⼀个脏时间戳⽽不覆盖它
         // （⽐较当前请求实例租约 和 已有租约 的LastDirtyTimestamp，选择靠后的）
        if (existingLease != null && (existingLease.getHolder() != null)) {
            Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();
            Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();
            logger.debug("Existing lease found (existing={}, provided={}", existingLastDirtyTimestamp, registrationLastDirtyTimestamp);

            // this is a > instead of a >= because if the timestamps are equal, we still take the remote transmitted
            // InstanceInfo instead of the server local copy.
            if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                logger.warn("There is an existing lease and the existing lease's dirty timestamp {} is greater" +
                        " than the one that is being registered {}", existingLastDirtyTimestamp, registrationLastDirtyTimestamp);
                logger.warn("Using the existing instanceInfo instead of the new instanceInfo as the registrant");
                registrant = existingLease.getHolder();
            }
        } else {
            // The lease does not exist and hence it is a new registration
            // 如果之前不存在实例的租约，说明是新实例注册
           // expectedNumberOfRenewsPerMin期待的每分钟续约数+2（因为30s⼀个）
          // 并更新numberOfRenewsPerMinThreshold每分钟续约阀值（85%）
            synchronized (lock) {
                if (this.expectedNumberOfClientsSendingRenews > 0) {
                    // Since the client wants to register it, increase the number of clients sending renews
                    this.expectedNumberOfClientsSendingRenews = this.expectedNumberOfClientsSendingRenews + 1;
                    updateRenewsPerMinThreshold();
                }
            }
            logger.debug("No previous lease information found; it is new registration");
        }
        Lease<InstanceInfo> lease = new Lease<InstanceInfo>(registrant, leaseDuration);
        if (existingLease != null) {
            lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
        }
         //当前实例信息放到维护注册信息的Map
        gMap.put(registrant.getId(), lease);
        // 同步维护最近注册队列
        synchronized (recentRegisteredQueue) {
            recentRegisteredQueue.add(new Pair<Long, String>(
                    System.currentTimeMillis(),
                    registrant.getAppName() + "(" + registrant.getId() + ")"));
        }
        // This is where the initial state transfer of overridden status happens
        // 如果当前实例已经维护了OverriddenStatus，将其也放到此EurekaServer的overriddenInstanceStatusMap中
        if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) {
            logger.debug("Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                            + "overrides", registrant.getOverriddenStatus(), registrant.getId());
            if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) {
                logger.info("Not found overridden id {} and hence adding it", registrant.getId());
                overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());
            }
        }
        InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());
        if (overriddenStatusFromMap != null) {
            logger.info("Storing overridden status {} from map", overriddenStatusFromMap);
            registrant.setOverriddenStatus(overriddenStatusFromMap);
        }

        // Set the status based on the overridden status rules
        // 根据overridden status规则，设置状态
        InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);
        registrant.setStatusWithoutDirty(overriddenInstanceStatus);

        // If the lease is registered with UP status, set lease service up timestamp
        // 如果租约以UP状态注册，设置租赁服务时间戳
        if (InstanceStatus.UP.equals(registrant.getStatus())) {
            lease.serviceUp();
        }
         //ActionType为ADD
        registrant.setActionType(ActionType.ADDED);
        //维护recentlyChangedQueue
        recentlyChangedQueue.add(new RecentlyChangedItem(lease));
        //更新最后更新时间
        registrant.setLastUpdatedTimestamp();
        // 使当前应⽤的ResponseCache失效
        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());
        logger.info("Registered instance {}/{} with status {} (replication={})",
                registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);
    } finally {
        read.unlock();
    }
}
```

PeerAwareInstanceRegistryImpl#replicateToPeers() ：复制到Eureka对等节点

```java
/**
 * Replicates all eureka actions to peer eureka nodes except for replication
 * traffic to this node.
 *
 */
private void replicateToPeers(Action action, String appName, String id,
                              InstanceInfo info /* optional */,
                              InstanceStatus newStatus /* optional */, boolean isReplication) {
    Stopwatch tracer = action.getTimer().start();
    try {
        // 如果是复制操作（针对当前节点，false）
        if (isReplication) {
            numberOfReplicationsLastMin.increment();
        }
        // If it is a replication already, do not replicate again as this will create a poison replication
        // 如果它已经是复制，请不要再次复制，直接return
        if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
            return;
        }
         // 遍历集群所有节点（除当前节点外）
        for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
            // If the url represents this host, do not replicate to yourself.
            if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) {
                continue;
            }
            // 复制Instance实例操作到某个node节点
            replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);
        }
    } finally {
        tracer.stop();
    }
}



/**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     * 复制Instance实例操作到某个node节点
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                    //下架
                case Cancel:
                    node.cancel(appName, id);
                    break;
                 //心跳续约
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, false);
                    break;
                //注册
                case Register:
                    node.register(info);
                    break;
                //状态更新
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                //删除节点
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error("Cannot replicate information to {} for action {}", node.getServiceUrl(), action.name(), t);
        }
    }
```

#### 1.5.4 Eureka Server服务续约接⼝（接受客户端续约）

com.netflix.eureka.resources.InstanceResource的renewLease⽅法中完成客户端的⼼跳（续约）处理，关键代码：registry.renew(app.getName(), id, isFromReplicaNode);

```java
@PUT
public Response renewLease(
        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
        @QueryParam("overriddenstatus") String overriddenStatus,
        @QueryParam("status") String status,
        @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
    boolean isFromReplicaNode = "true".equals(isReplication);
    //调用续约
    boolean isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);

    // Not found in the registry, immediately ask for a register
    if (!isSuccess) {
        logger.warn("Not Found (Renew): {} - {}", app.getName(), id);
        return Response.status(Status.NOT_FOUND).build();
    }
    // Check if we need to sync based on dirty time stamp, the client
    // instance might have changed some value
    // 更改最后操作时间 
    Response response;
    if (lastDirtyTimestamp != null && serverConfig.shouldSyncWhenTimestampDiffers()) {
        response = this.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);
        // Store the overridden status since the validation found out the node that replicates wins
        if (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()
                && (overriddenStatus != null)
                && !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))
                && isFromReplicaNode) {
            registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));
        }
    } else {
        response = Response.ok().build();
    }
    logger.debug("Found (Renew): {} - {}; reply status={}", app.getName(), id, response.getStatus());
    return response;
}
```

com.netflflix.eureka.registry.PeerAwareInstanceRegistryImpl#renew

```java
public boolean renew(final String appName, final String id, final boolean isReplication) {
    //本地renew操作
    if (super.renew(appName, id, isReplication)) {
        //同步到其他Eureka节点
        replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);
        return true;
    }
    return false;
}
```

####  1.5.5 Eureka Client注册服务

启动过程：Eureka客户端在启动时也会装载很多配置类，我们通过spring-cloud-netflflix-eureka-client-2.1.0.RELEASE.jar下的spring.factories⽂件可以看到加载的配置类。

![cloud-eureka8](03.Spring%20Cloud%20Netfix%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.assets/cloud-eureka8.png)

```java
@Configuration
@EnableConfigurationProperties
@ConditionalOnClass(EurekaClientConfig.class)
@Import(DiscoveryClientOptionalArgsConfiguration.class)
@ConditionalOnBean(EurekaDiscoveryClientConfiguration.Marker.class)
@ConditionalOnProperty(value = "eureka.client.enabled", matchIfMissing = true)
@AutoConfigureBefore({ NoopDiscoveryClientAutoConfiguration.class,
      CommonsClientAutoConfiguration.class, ServiceRegistryAutoConfiguration.class })
//必须把配置的bean装配完毕才能装配当前类
@AutoConfigureAfter(name = {"org.springframework.cloud.autoconfigure.RefreshAutoConfiguration",
      "org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration",
      "org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration"})
public class EurekaClientAutoConfiguration {
```

如果项目引用了Eureka客户端相关jar，但不想作为客户端，可以设置eureka.client.enabled=false

```java
@Configuration
@EnableConfigurationProperties
@ConditionalOnClass(EurekaClientConfig.class)
@ConditionalOnProperty(value = "eureka.client.enabled", matchIfMissing = true)
public class EurekaDiscoveryClientConfiguration {

   class Marker {}
   //自动装配中eureka会自动装配一个Marker,所以不加@EnableEurekaClient也可以
   @Bean
   public Marker eurekaDiscoverClientMarker() {
      return new Marker();
   }
```

回到主配置类EurekaClientAutoConfifiguration。

思考：EurekaClient启动过程要做什么事情？

1. 读取配置⽂件
2. 启动时从EurekaServer获取服务实例信息
3. 注册⾃⼰到EurekaServer（addInstance） 
4. 开启⼀些定时任务（⼼跳续约，刷新本地服务缓存列表）

1. **读取配置⽂件**

   ```java
   @Bean
   @ConditionalOnMissingBean(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT)
   public EurekaInstanceConfigBean eurekaInstanceConfigBean(InetUtils inetUtils,
                                              ManagementMetadataProvider managementMetadataProvider) {
      String hostname = getProperty("eureka.instance.hostname");
      boolean preferIpAddress = Boolean.parseBoolean(getProperty("eureka.instance.prefer-ip-address"));
      String ipAddress = getProperty("eureka.instance.ip-address");
      boolean isSecurePortEnabled = Boolean.parseBoolean(getProperty("eureka.instance.secure-port-enabled"));
   
      String serverContextPath = env.getProperty("server.context-path", "/");
      int serverPort = Integer.valueOf(env.getProperty("server.port", env.getProperty("port", "8080")));
   
      Integer managementPort = env.getProperty("management.server.port", Integer.class);// nullable. should be wrapped into optional
      String managementContextPath = env.getProperty("management.server.servlet.context-path");// nullable. should be wrapped into optional
      Integer jmxPort = env.getProperty("com.sun.management.jmxremote.port", Integer.class);//nullable
      EurekaInstanceConfigBean instance = new EurekaInstanceConfigBean(inetUtils);
   
      instance.setNonSecurePort(serverPort);
      instance.setInstanceId(getDefaultInstanceId(env));
      instance.setPreferIpAddress(preferIpAddress);
      instance.setSecurePortEnabled(isSecurePortEnabled);
      if (StringUtils.hasText(ipAddress)) {
         instance.setIpAddress(ipAddress);
      }
   
      if(isSecurePortEnabled) {
         instance.setSecurePort(serverPort);
      }
   
      if (StringUtils.hasText(hostname)) {
         instance.setHostname(hostname);
      }
      String statusPageUrlPath = getProperty("eureka.instance.status-page-url-path");
      String healthCheckUrlPath = getProperty("eureka.instance.health-check-url-path");
   
      if (StringUtils.hasText(statusPageUrlPath)) {
         instance.setStatusPageUrlPath(statusPageUrlPath);
      }
      if (StringUtils.hasText(healthCheckUrlPath)) {
         instance.setHealthCheckUrlPath(healthCheckUrlPath);
      }
   
      ManagementMetadata metadata = managementMetadataProvider.get(instance, serverPort,
            serverContextPath, managementContextPath, managementPort);
   
      if(metadata != null) {
         instance.setStatusPageUrl(metadata.getStatusPageUrl());
         instance.setHealthCheckUrl(metadata.getHealthCheckUrl());
         if(instance.isSecurePortEnabled()) {
            instance.setSecureHealthCheckUrl(metadata.getSecureHealthCheckUrl());
         }
         Map<String, String> metadataMap = instance.getMetadataMap();
         if (metadataMap.get("management.port") == null) {
            metadataMap.put("management.port", String.valueOf(metadata.getManagementPort()));
         }
      } else {
         //without the metadata the status and health check URLs will not be set
         //and the status page and health check url paths will not include the
         //context path so set them here
         if(StringUtils.hasText(managementContextPath)) {
            instance.setHealthCheckUrlPath(managementContextPath + instance.getHealthCheckUrlPath());
            instance.setStatusPageUrlPath(managementContextPath + instance.getStatusPageUrlPath());
         }
      }
   
      setupJmxPort(instance, jmxPort);
      return instance;
   }
   ```

2. **启动时从EurekaServer获取服务实例信息**

   ```java
   //实例化EurekaClient，返回CloudEurekaClient
   @Bean(destroyMethod = "shutdown")
   @ConditionalOnMissingBean(value = EurekaClient.class, search = SearchStrategy.CURRENT)
   @org.springframework.cloud.context.config.annotation.RefreshScope
   @Lazy
   public EurekaClient eurekaClient(ApplicationInfoManager manager, EurekaClientConfig config, EurekaInstanceConfig instance,
                            @Autowired(required = false) HealthCheckHandler healthCheckHandler) {
      //If we use the proxy of the ApplicationInfoManager we could run into a problem
      //when shutdown is called on the CloudEurekaClient where the ApplicationInfoManager bean is
      //requested but wont be allowed because we are shutting down.  To avoid this we use the
      //object directly.
      ApplicationInfoManager appManager;
      if(AopUtils.isAopProxy(manager)) {
         appManager = ProxyUtils.getTargetObject(manager);
      } else {
         appManager = manager;
      }
      CloudEurekaClient cloudEurekaClient = new CloudEurekaClient(appManager, config, this.optionalArgs,
            this.context);
      cloudEurekaClient.registerHealthCheck(healthCheckHandler);
      return cloudEurekaClient;
   }
   // CloudEurekaClient构造函数
   public CloudEurekaClient(ApplicationInfoManager applicationInfoManager,
   							 EurekaClientConfig config,
   							 AbstractDiscoveryClientOptionalArgs<?> args,
   							 ApplicationEventPublisher publisher) {
           //调用父类
   		super(applicationInfoManager, config, args);
   		this.applicationInfoManager = applicationInfoManager;
   		this.publisher = publisher;
   		this.eurekaTransportField = ReflectionUtils.findField(DiscoveryClient.class, "eurekaTransport");
   		ReflectionUtils.makeAccessible(this.eurekaTransportField);
   	}
   
   //  观察⽗类DiscoveryClient()
      public DiscoveryClient(ApplicationInfoManager applicationInfoManager, final EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args) {
           //调用另外构造函数
           this(applicationInfoManager, config, args, new Provider<BackupRegistry>() {
               private volatile BackupRegistry backupRegistryInstance;
                //省。。
               }
           });
       }
   
    //从服务注册中心获取实例
    private boolean fetchRegistry(boolean forceFullRegistryFetch) {
           Stopwatch tracer = FETCH_REGISTRY_TIMER.start();
   
           try {
               // If the delta is disabled or if it is the first time, get all
               // applications
               Applications applications = getApplications();
   
               if (clientConfig.shouldDisableDelta()
                       || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))
                       || forceFullRegistryFetch
                       || (applications == null)
                       || (applications.getRegisteredApplications().size() == 0)
                       || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta
               {
                   logger.info("Disable delta property : {}", clientConfig.shouldDisableDelta());
                   logger.info("Single vip registry refresh property : {}", clientConfig.getRegistryRefreshSingleVipAddress());
                   logger.info("Force full registry fetch : {}", forceFullRegistryFetch);
                   logger.info("Application is null : {}", (applications == null));
                   logger.info("Registered Applications size is zero : {}",
                           (applications.getRegisteredApplications().size() == 0));
                   logger.info("Application version is -1: {}", (applications.getVersion() == -1));
                   //全量获取
                   getAndStoreFullRegistry();
               } else {
                   //增量获取
                   getAndUpdateDelta(applications);
               }
               applications.setAppsHashCode(applications.getReconcileHashCode());
               logTotalInstances();
           } catch (Throwable e) {
               logger.error(PREFIX + "{} - was unable to refresh its cache! status = {}", appPathIdentifier, e.getMessage(), e);
               return false;
           } finally {
               if (tracer != null) {
                   tracer.stop();
               }
           }
   
           // Notify about cache refresh before updating the instance remote status
           onCacheRefreshed();
   
           // Update remote status based on refreshed data held in the cache
           updateInstanceRemoteStatus();
   
           // registry was fetched successfully, so return true
           return true;
       }
   ```

3.  **注册自己到EurekaServer**

```java
if (clientConfig.shouldRegisterWithEureka() && clientConfig.shouldEnforceRegistrationAtInit()) {
    try {
        //注册自己
        if (!register() ) {
            throw new IllegalStateException("Registration error at startup. Invalid server response.");
        }
    } catch (Throwable th) {
        logger.error("Registration error at startup: {}", th.getMessage());
        throw new IllegalStateException(th);
    }
}

   /**
     * Register with the eureka service by making the appropriate REST call.
     */
boolean register() throws Throwable {
    logger.info(PREFIX + "{}: registering service...", appPathIdentifier);
    EurekaHttpResponse<Void> httpResponse;
    try {
        //向Eureka服务端注册自己信息，底层使⽤Jersey客户端进⾏远程请求。
        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
    } catch (Exception e) {
        logger.warn(PREFIX + "{} - registration failed {}", appPathIdentifier, e.getMessage(), e);
        throw e;
    }
    if (logger.isInfoEnabled()) {
        logger.info(PREFIX + "{} - registration status: {}", appPathIdentifier, httpResponse.getStatusCode());
    }
    return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();
}
```

4.  **开启⼀些定时任务（⼼跳续约，刷新本地服务缓存列表）**

com.netflix.discovery.DiscoveryClient#initScheduledTasks

```java
    /**
     * Initializes all scheduled tasks.
     */
    private void initScheduledTasks() {
        if (clientConfig.shouldFetchRegistry()) {
            // registry cache refresh timer
            int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
            int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
            //定时刷新缓存
            scheduler.schedule(
                    new TimedSupervisorTask(
                            "cacheRefresh",
                            scheduler,
                            cacheRefreshExecutor,
                            registryFetchIntervalSeconds,
                            TimeUnit.SECONDS,
                            expBackOffBound,
                            new CacheRefreshThread()
                    ),
                    registryFetchIntervalSeconds, TimeUnit.SECONDS);
        }

        if (clientConfig.shouldRegisterWithEureka()) {
            int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();
            int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();
            logger.info("Starting heartbeat executor: " + "renew interval is: {}", renewalIntervalInSecs);

            // Heartbeat timer
            //定时心跳续约
            scheduler.schedule(
                    new TimedSupervisorTask(
                            "heartbeat",
                            scheduler,
                            heartbeatExecutor,
                            renewalIntervalInSecs,
                            TimeUnit.SECONDS,
                            expBackOffBound,
                            new HeartbeatThread()
                    ),
                    renewalIntervalInSecs, TimeUnit.SECONDS);

            // InstanceInfo replicator
            instanceInfoReplicator = new InstanceInfoReplicator(
                    this,
                    instanceInfo,
                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                    2); // burstSize

            statusChangeListener = new ApplicationInfoManager.StatusChangeListener() {
                @Override
                public String getId() {
                    return "statusChangeListener";
                }

                @Override
                public void notify(StatusChangeEvent statusChangeEvent) {
                    if (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||
                            InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) {
                        // log at warn level if DOWN was involved
                        logger.warn("Saw local status change event {}", statusChangeEvent);
                    } else {
                        logger.info("Saw local status change event {}", statusChangeEvent);
                    }
                    instanceInfoReplicator.onDemandUpdate();
                }
            };

            if (clientConfig.shouldOnDemandUpdateStatusChange()) {
                applicationInfoManager.registerStatusChangeListener(statusChangeListener);
            }

            instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());
        } else {
            logger.info("Not registering with Eureka server per configuration");
        }
    }

```

####  1.5.6 **Eureka Client下架服务**

org.springframework.cloud.netflix.eureka.**EurekaClientAutoConfiguration**

```java
//服务下架入口，当客户端工程关闭容器销毁的时候会调用shutdown方法执行一下清理操作，下线操作
@Bean(destroyMethod = "shutdown")
@ConditionalOnMissingBean(value = EurekaClient.class, search = SearchStrategy.CURRENT)
public EurekaClient eurekaClient(ApplicationInfoManager manager, EurekaClientConfig config) {
   return new CloudEurekaClient(manager, config, this.optionalArgs,
         this.context);
}
```

com.netflix.discovery.**DiscoveryClient**

```java
//关闭资源，取消注册，向服务注册中心发送下线请求
@PreDestroy
@Override
public synchronized void shutdown() {
    if (isShutdown.compareAndSet(false, true)) {
        logger.info("Shutting down DiscoveryClient ...");

        if (statusChangeListener != null && applicationInfoManager != null) {
            applicationInfoManager.unregisterStatusChangeListener(statusChangeListener.getId());
        }

        cancelScheduledTasks();

        // If APPINFO was registered
        if (applicationInfoManager != null
                && clientConfig.shouldRegisterWithEureka()
                && clientConfig.shouldUnregisterOnShutdown()) {
            applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);
            unregister();
        }

        if (eurekaTransport != null) {
            eurekaTransport.shutdown();
        }

        heartbeatStalenessMonitor.shutdown();
        registryStalenessMonitor.shutdown();

        logger.info("Completed shut down of DiscoveryClient");
    }
}



  /**
     * unregister w/ the eureka service.
     * 注销注册实例
     */
    void unregister() {
        // It can be null if shouldRegisterWithEureka == false
        if(eurekaTransport != null && eurekaTransport.registrationClient != null) {
            try {
                logger.info("Unregistering ...");
                EurekaHttpResponse<Void> httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());
                logger.info(PREFIX + "{} - deregister  status: {}", appPathIdentifier, httpResponse.getStatusCode());
            } catch (Exception e) {
                logger.error(PREFIX + "{} - de-registration failed{}", appPathIdentifier, e.getMessage(), e);
            }
        }
    }
```

## **第** **2** **节** **Ribbon负载均衡**

### **2.1** **关于负载均衡**

负载均衡⼀般分为**服务器端负载均衡**和**客户端负载均衡**。

所谓**服务器端负载均衡**，⽐如Nginx、F5这些，请求到达服务器之后由这些负载均衡器根据⼀定的算法将请求路由到⽬标服务器处理。

所谓**客户端负载均衡**，⽐如我们要说的Ribbon，服务消费者客户端会有⼀个服务器地址列表，调⽤⽅在请求前通过⼀定的负载均衡算法选择⼀个服务器进⾏访问，负载均衡算法的执⾏是在请求客户端进⾏。

Ribbon是Netflflix发布的负载均衡器。Eureka⼀般配合Ribbon进⾏使⽤，Ribbon利⽤从Eureka中读取到服务信息，在调⽤服务提供者提供的服务时，会根据⼀定的算法进⾏负载。

### 2.2 Ribbon高级应用

不需要引入额外的Jar坐标，因为在服务消费者中我们引入过eureka-client，它会引入Ribbon相关Jar。

代码中使用如下，在RestTemplate上添加对应注解即可。

```java
@Bean
// Ribbon负载均衡
@LoadBalanced
public RestTemplate getRestTemplate() {
 return new RestTemplate();
}
```

修改服务提供者api返回值，返回当前实例的端口号，便于观察负载情况。

```java
@RestController
@RequestMapping(value = "/provider")
public class ProviderController {

    @Value(value = "${server.port}")
    private Integer port;

    @GetMapping("/getPort")
    public Integer getPort(){
        return port;
    }
}
```

消费端测试一下负载情况，多台部署会出现轮训调用。

```java
@RestController
@RequestMapping("/consume")
public class ConsumeController {

    @Resource
    private RestTemplate restTemplate;

    @Bean
    // Ribbon负载均衡
    @LoadBalanced
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }

    @GetMapping("/getPort")
    public Integer getPort(){
        return restTemplate.getForObject("http://learn-cloud-eureka-client-provider/provider//getPort",Integer.class);
    }
}
```

### 2.3 Ribbon负载均衡策略

Ribbon内置了多种负载均衡策略，内部负责复杂均衡的顶级接⼝为com.netflflix.loadbalancer.IRule ，类树如下

![image-20220103213310028](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/image-20220103213310028.png)

| **负载均衡策略**                                | **描述**                                                     |
| ----------------------------------------------- | ------------------------------------------------------------ |
| RoundRobinRule：轮询策略                        | 默认超过10次获取到的server都不可用，会返回⼀个空的server     |
| RandomRule：随机策略                            | 如果随机到的server为null或者不可⽤的话，会while不停的循环选取 |
| RetryRule：重试策略                             | ⼀定时限内循环重试。默认继承RoundRobinRule，也⽀持自定义注入，RetryRule会在每次选取之后，对选举的server进行判断，是否为null，是否alive，并且在500ms内会不停的选取判断。而RoundRobinRule失效的策略是超过10次，RandomRule是没有失效时 |
| BestAvailableRule：最小连接数策略               | 遍历serverList，选取出可用的且连接数最小的⼀个server。该算法里面有⼀个LoadBalancerStats的成员变量，会存储所有server的运行状况和连接数。如果选取到的server为null，那么会调用RoundRobinRule重新选取。 |
| AvailabilityFilteringRule：可⽤过滤策略         | 扩展了轮询策略，会先通过默认的轮询选取⼀个server，再去判断该server是否超时可用，当前连接数是否超限，都成功再返回。 |
| ZoneAvoidanceRule：区域权衡策略**（默认策略）** | 扩展了轮询策略，继承了2个过滤器：ZoneAvoidancePredicate和AvailabilityPredicate，除了过滤超时和链接数过多的server，还会过滤掉不符合要求的zone区域里面的所有节点，AWS --ZONE 在⼀个区域/机房内的服务实例中轮询。 |

修改负载均衡策略，配置如下：

```yaml
#针对的被调⽤⽅微服务名称,不加就是全局⽣效
learn-cloud-eureka-client-provider:
  ribbon:
    NFLoadBalancerRuleClassName:
      com.netflix.loadbalancer.RandomRule #负载策略调整
```

### 2.4 Ribbon核心源码剖析

**Ribbon工作原理**

![cloud-ribbon](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-ribbon.jpg)

图中核心是**负载均衡管理器LoadBalancer**，围绕它周围的多有IRule、IPing等

- IRule：是在选择实例的时候的负载均衡策略对象
- IPing：是用来向服务发起心跳检测的，通过心跳检测来判断该服务是否可用
- ServerListFilter：根据⼀些规则过滤传入的服务实例列表
- ServerListUpdater：定义了⼀系列的对服务列表的更新操作

####  2.4.1 @LoadBalanced源码剖析

我们在RestTemplate实例上添加了⼀个@LoadBalanced注解，就可以实现负载均衡，很神奇，我们接下来分析这个注解背后的操作（负载均衡过程）

- 查看@LoadBalanced注解，那这个注解是在哪⾥被识别到的呢？

```java
/**
 * Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient.
 * @author Spencer Gibb
 * 英文注释：使用@LoadBalanced注解后，可以将RestTemplate对象用LoadBalancerClient进行处理
 */
@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Qualifier
public @interface LoadBalanced {
}
```

- 根据上面注释，查看org.springframework.cloud.client.loadbalancer.LoadBalancerClient类

```java
/**
 * Represents a client-side load balancer.
 * @author Spencer Gibb
 */
public interface LoadBalancerClient extends ServiceInstanceChooser {

   /**
    * Executes request using a ServiceInstance from the LoadBalancer for the specified
    * service.
    * @param serviceId The service ID to look up the LoadBalancer.
    * @param request Allows implementations to execute pre and post actions, such as
    * incrementing metrics.
    * @return The result of the LoadBalancerRequest callback on the selected
    * ServiceInstance.
    * 根据服务执⾏请求内容
    */
   <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException;

   /**
    * Executes request using a ServiceInstance from the LoadBalancer for the specified
    * service.
    * @param serviceId The service ID to look up the LoadBalancer.
    * @param serviceInstance The service to execute the request to.
    * @param request Allows implementations to execute pre and post actions, such as
    * incrementing metrics.
    * @return The result of the LoadBalancerRequest callback on the selected
    * ServiceInstance.
    *  根据服务执⾏请求内容
    */
   <T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException;

   /**
    * Creates a proper URI with a real host and port for systems to utilize.
    * Some systems use a URI with the logical service name as the host,
    * such as http://myservice/path/to/service.  This will replace the
    * service name with the host:port from the ServiceInstance.
    * @param instance
    * @param original A URI with the host as a logical service name.
    * @return A reconstructed URI.
    *  拼接请求⽅式 传统中是ip:port 现在是服务名称:port 形式
    */
   URI reconstructURI(ServiceInstance instance, URI original);
}
```

- 利用Spring Boot自动装配的特点，找到spring.factories配置⽂件，查看Ribbon自动装配类

![cloud-ribbon1](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-ribbon1.png)

- 查看org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration类

```java
@Configuration
@Conditional(RibbonAutoConfiguration.RibbonClassesConditions.class)
@RibbonClients
@AutoConfigureAfter(name = "org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration")
@AutoConfigureBefore({LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class})
@EnableConfigurationProperties({RibbonEagerLoadProperties.class, ServerIntrospectorProperties.class})
public class RibbonAutoConfiguration {
}
```

可以看到**LoadBalancerAutoConfiguration，AsyncLoadBalancerAutoConfiguration** 将会在 **RibbonAutoConfiguration** 之后加载。

- 首先查看org.springframework.cloud.client.loadbalancer.**LoadBalancerAutoConfiguration**类。

可以看到只有存在RestTemplate这个类，LoadBalancerClient这个对象，该配置类才装配生效。

添加了注解的RestTemplate对象会被添加⼀个拦截器LoadBalancerInterceptor，该拦截器就是后续拦截请求进⾏负载处理的。

```java
@Configuration
@ConditionalOnClass(RestTemplate.class)
@ConditionalOnBean(LoadBalancerClient.class)
@EnableConfigurationProperties(LoadBalancerRetryProperties.class)
public class LoadBalancerAutoConfiguration {
    
    //第一步，此处会自动注入那些添加@LoadBalanced注解的RestTemplate对象
    @LoadBalanced
	@Autowired(required = false)
	private List<RestTemplate> restTemplates = Collections.emptyList();
    
    @Bean
	public SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated(
			final ObjectProvider<List<RestTemplateCustomizer>> restTemplateCustomizers) {
		return () -> restTemplateCustomizers.ifAvailable(customizers -> {
            // 第二步：给RestTemplate对象添加一个拦截器
            for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) {
                for (RestTemplateCustomizer customizer : customizers) {
                    customizer.customize(restTemplate);
                }
            }
        });
	}
    // 负载均衡过滤器配置
    @Configuration
	@ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")
	static class LoadBalancerInterceptorConfig {
		@Bean
		public LoadBalancerInterceptor ribbonInterceptor(
				LoadBalancerClient loadBalancerClient,
				LoadBalancerRequestFactory requestFactory) {
			return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);
		}

        // 注⼊RestTemplate定制器
		@Bean
		@ConditionalOnMissingBean
		public RestTemplateCustomizer restTemplateCustomizer(
				final LoadBalancerInterceptor loadBalancerInterceptor) {
			return restTemplate -> {
                //添加loadBalancerInterceptor过滤器
                List<ClientHttpRequestInterceptor> list = new ArrayList<>(
                        restTemplate.getInterceptors());
                list.add(loadBalancerInterceptor);
                restTemplate.setInterceptors(list);
            };
		}
	}
}
```

- 接下来，分析拦截器LoadBalancerInterceptor

```java
public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor {

   private LoadBalancerClient loadBalancer;
   private LoadBalancerRequestFactory requestFactory;

   public LoadBalancerInterceptor(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory) {
      this.loadBalancer = loadBalancer;
      this.requestFactory = requestFactory;
   }

   public LoadBalancerInterceptor(LoadBalancerClient loadBalancer) {
      // for backwards compatibility
      this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer));
   }

   @Override
   public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,
         final ClientHttpRequestExecution execution) throws IOException {
      //获取拦截请求uri，比如 http://learn-cloud-eureka-client-provider/provider/getPort
      final URI originalUri = request.getURI();
      //获取uri的服务名，比如：learn-cloud-eureka-client-provider
      String serviceName = originalUri.getHost();
      Assert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri);
      //接下来交给LoadBalanceClient对象负责执行，具体执行的子类是RibbonLoadBalanceClient对象
      return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));
   }
}
```

![cloud-ribbon2](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/cloud-ribbon2.png)

- 那么，RibbonLoadBalanceClient是何时注入的呢？回到最初的⾃动配置类RibbonAutoConfifiguration中

```java
@Bean
@ConditionalOnMissingBean(LoadBalancerClient.class)
public LoadBalancerClient loadBalancerClient() {
   return new RibbonLoadBalancerClient(springClientFactory());
}
```

- 负载均衡的事情执行交到RibbonLoadBalancerClient对象，非常核心的⼀个⽅法：RibbonLoadBalancerClient.execute()

```java
/**
 * New: Execute a request by selecting server using a 'key'.
 * The hint will have to be the last parameter to not mess with the `execute(serviceId, ServiceInstance, request)`
 * method. This somewhat breaks the fluent coding style when using a lambda to define the LoadBalancerRequest.
 */
public <T> T execute(String serviceId, LoadBalancerRequest<T> request, Object hint) throws IOException {
    //关注点1：如何获取负载均衡器对象，默认为ZoneAwareLoadBalancer
   ILoadBalancer loadBalancer = getLoadBalancer(serviceId);
   //关注点2：如何通过负载均衡器最终获取一个可用的服务节点
   Server server = getServer(loadBalancer, hint);
   if (server == null) {
      throw new IllegalStateException("No instances available for " + serviceId);
   }
   //把server封装成RibbonServer
   RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server,
         serviceId), serverIntrospector(serviceId).getMetadata(server));

   return execute(serviceId, ribbonServer, request);
}

@Override
public <T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException {
   Server server = null;
   if(serviceInstance instanceof RibbonServer) {
      server = ((RibbonServer)serviceInstance).getServer();
   }
   if (server == null) {
      throw new IllegalStateException("No instances available for " + serviceId);
   }

   RibbonLoadBalancerContext context = this.clientFactory
         .getLoadBalancerContext(serviceId);
   RibbonStatsRecorder statsRecorder = new RibbonStatsRecorder(context, server);

   try {
      //关注点3：如何向服务提供者节点发起请求的关键步骤
      T returnVal = request.apply(serviceInstance);
      statsRecorder.recordStats(returnVal);
      return returnVal;
   }
   // catch IOException and rethrow so RestTemplate behaves correctly
   catch (IOException ex) {
      statsRecorder.recordStats(ex);
      throw ex;
   }
   catch (Exception ex) {
      statsRecorder.recordStats(ex);
      ReflectionUtils.rethrowRuntimeException(ex);
   }
   return null;
}
```

- 关注点1：先看ILoadBalancer loadBalancer = getLoadBalancer(serviceId);负载均衡器对象是何时注入容器的？

  ```java
  private SpringClientFactory clientFactory;
  
  protected ILoadBalancer getLoadBalancer(String serviceId) {
     return this.clientFactory.getLoadBalancer(serviceId);
  }
  ```

​     查看SpringClientFactory的构造函数，发现会注入RibbonClientConfiguration类

```java
public class SpringClientFactory extends NamedContextFactory<RibbonClientSpecification> {

   static final String NAMESPACE = "ribbon";

   public SpringClientFactory() {
      super(RibbonClientConfiguration.class, NAMESPACE, "ribbon.client.name");
   }
}
```

来看看RibbonClientConfiguration类

```java
@Configuration
@EnableConfigurationProperties
//Order is important here, last should be the default, first should be optional
// see https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653
@Import({HttpClientConfiguration.class, OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class})
public class RibbonClientConfiguration {
    //默认配置区域均衡策略
    @Bean
	@ConditionalOnMissingBean
	public IRule ribbonRule(IClientConfig config) {
		if (this.propertiesFactory.isSet(IRule.class, name)) {
			return this.propertiesFactory.get(IRule.class, config, name);
		}
		ZoneAvoidanceRule rule = new ZoneAvoidanceRule();
		rule.initWithNiwsConfig(config);
		return rule;
	}
}
```