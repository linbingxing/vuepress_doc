#  MySQL索引原理

## 1 索引类型

索引类型如下：

- 从索引存储结构划分：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引
- 从应用层次划分：普通索引、唯一索引、主键索引、复合索引
- 从索引键值类型划分：主键索引、辅助索引
- 从数据存储和索引键值逻辑关键划分：聚集索引，非聚集索引

### 1.1 普遍索引

这是最基本的索引类型，基于普通字段建立的索引，没有任何限制。

创建普通索引的方法如下：

- `CREATE INDEX <索引的名称> ON TABLENAME(字段名)`
- `ALTER TABLE tableName ADD INDEX [索引名称]（字段名）`
- `CREATE TABLE tableName[...],INDEX[索引名称]（字段名）`

###  1.2 唯一索引

与普通索引类似，不同的就是：索引字段的值必须唯一，但允许有空值，在创建或者修改时追加唯一约束，就会自动创建对应的唯一索引。

创建唯一索引的方法如下：

- `CREATE UNIQUE INDEX <索引的名称> ON TABLENAME(字段名)`
- `ALTER TABLE tableName ADD UNIQUE INDEX [索引名称]（字段名）`
- `CREATE TABLE tableName[...],UNIQUE[索引名称]（字段名）`

###  1.3 主键索引

她是一种特殊的唯一索引，不允许有空值，在创建或者修改表时追加主键约束即可，每个表只能有一个主键。

创建主键索引的方法如下：

- CREATE TABLE tableName[...],PRIMARY KEY(字段名)
- ALTER TABLE tableName ADD PRIMARY KEY(字段名)

###  1.4  复合索引

用户可以在多个列上建立索引。复合索引在数据库操作期间所需的开销更新，可以替代多个单一索引。

索引同时有两个概念叫做窄索引和宽索引，窄索引是指索引为1-2列的索引，宽索引也就是索引列超过2列的索引，设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比宽索引更有效。

创建复合索引的方法如下：

- `CREATE INDEX <索引的名称> ON TABLENAME(字段名1,字段2,...)`
- `ALTER TABLE tableName ADD INDEX [索引名称]（字段名1,字段2,...）`
- `CREATE TABLE tableName[...],INDEX[索引名称]（字段名1,字段2,...）`

###  1.5 全文索引

在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果使用全文索引，查询速度会比like快很多倍。在MySQL5.6以前的版本，只有MyISAM存储引擎支持全文索引，在MySQL 5.6开始MyISAM和InnoDB存储引擎均支持。

创建全文索引的方法如下：

- `CREATE FULLTEXT INDEX <索引的名称> ON TABLENAME(字段名)`
- `ALTER TABLE tableName ADD FULLTEXT [索引名称]（字段名）`
- `CREATE TABLE tableName[...],FULLTEXT KEY [索引名称]（字段名）`

和常用的like模糊查询不同，全文索引使用match、against。

全文索引必须在字符串，文本字段上建立。

全文索引必须在字符3~84字符进行才有有效。

全文索引字段值要进行切词处理，按照syntax字符进行切割。

全文索引匹配查询，默认使用的是等值匹配。

```sql
select * from test where match(name) against();

select * from test where match(name) against('aaa*' in boolean model)
```

## 2 索引原理

MySQL官方对索引定义，是存储引擎用于快速查找记录的一种数据结构，需要额外开辟空间和数据维护工作。

- 索引是物理数据页存储，在数据文件中，利用数据页page存储。
- 索引可以加快检索速度，但是同时降低增删改的操作速度，索引维护需要代价。

索引涉及的理论知识：二分查找法，Hash和B+Tree。

### 2.1 二分查找法

二分查找法也叫做折半查找法，它是在有序数据中查找指定数据的搜索算法，它的优点是等值查询，范围查询性能优秀，缺点是更新、新增、删除数据的维护成本高。

### 2.2 Hash结构

Hash底层实现是由Hash表来实现的，是根据键值<key,value>存储数据的结构，非常适合根据Key查找value。

Hash索引可以方便提供等值查询，但是对于范围查询就需要全表扫描了。

Hash索引在MySQL中Hash结构主要应用在Memory原生的Hash索引，InnoDB自适应哈希索引。

InnoDB提供的自适应哈希索引功能强大，主要是为了提升查询效率，InnoDB存储引擎会监控表上各个索引页的查询，当InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+tree索引再创建一个哈希索引，使得内存中的B+tree索引具备哈希索引的功能，能够快速定值访问频繁访问的索引页。

自适应哈希索引的建立使得InnoDB存储引擎能自动根据索引页访问的频率和模式自动为某些热点页建立哈希索引来加速访问。自适应哈希索引的功能，只能选择开启或者关闭。

###  2.3 B+Tree结构

MySQL数据库采用的是B+Tree结构，在B+tree结构上做了优化改造。

- B-Tree结构

  - 索引值和data数据分布在整棵树结构中
  - 每个节点可以存放多个索引值以及对应的data数据
  - 树节点中的多个索引值从左到右升序排列

  ![image-20220320171807849](02.MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.assets/image-20220320171807849.png)

- B+Tree结构

  - 非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引
  - 叶子节点包含所有索引字段
  - 叶子节点用指针连接，提高区间访问的性能

  ![image-20220320171908449](02.MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.assets/image-20220320171908449.png)

### 2.4 聚簇索引和辅助索引

- 聚簇索引

  聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建B+Tree结构，B+Tree的叶子节点就是行记录，行记录和主键紧凑地存储在一起，这也意味着InnoDB的主键索引就是数据表本身，它被主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小，通常说主键索引就是聚簇索引。

  InnoDB的表要求必须要有聚簇索引：

  - 如果表定义了主键，则主键索引就是聚簇索引
  - 如果表没有定义主键，则第一个非空的唯一索引就是聚簇索引
  - 否则InnoDB会建一个隐藏的row_id作为聚簇索引

- 辅助索引

  InnoDB辅助索引，也叫做二级索引，是根据索引列构建B+Tree结构，但在B+Tree的叶子节点中只存了索引列和主键的信息。二级索引占用的空间比聚簇索引小很多，通常创建辅助索引就是为了提升查询效率。

  一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。

  辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

  ![img](02.MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.assets/7ab8ca28-2a41-4adf-9502-cc0a21e63b51.jpg)

- 非聚簇索引

  与InnoDB聚簇索引不同，MyISAM引擎使用的索引文件和数据文件是分开的，被称为非聚簇索引结构。

  ![image-20220320173744914](02.MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.assets/image-20220320173744914.png)

## 3  索引分析和优化

### 3.1 Explain

**Explain工具介绍** 

使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈 

在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是 执行这条SQL 

注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中

```shell
mysql> explain select * from  account where id > 4 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: account
   partitions: NULL
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

```

- **id列** 

  select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序

  三种情况：

  - id相同，执行顺序由上至下
  - id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
  - id相同不同同时存在

- **select_type列** 

  查询的类型，主要用于区别普通查询、联合查询、子查询等复杂查询。

  - simple：简单查询。查询不包含子查询和union
  - primary：查询中若包含任何复杂的子查询，最外层查询则被标记为primary
  - subquery：包含在 select 或者where中的子查询（不在 from 子句中） 
  - derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含 义）
  - union：在 union 中的第二个和随后的 select 
  - union result：从union表获取结果的select

- **table列** 

  这一列表示 explain 的一行正在访问哪个表。 

  当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查 询。

  当有 union 时，UNION RESULT 的 table 列的值为<union1,2>，1和2表示参与 union 的 select 行id。

- **type列** 

  这一列表示**关联类型或访问类型**，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 

  依次从最优到最差分别为：**system > const > eq_ref > ref > range > index > ALL** 

  一般来说，**得保证查询达到range级别，最好达到ref** 

  - all：即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。
  - index：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接 对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这 种通常比ALL快一些。 
  - range：范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。 
  - ref：是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。
  - eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。 
  - const：表示使用主键或者唯一索引等值查询，常量查询
  - system：**是** **const的特例**，表里只有一条元组匹配时为system 
  - null：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表 

- **possible_keys列**

  这一列显示查询可能使用哪些索引来查找。 

  explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引 对此查询帮助不大，选择了全表查询。 

  如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提 高查询性能，然后用 explain 查看效果。

- **key列** 

  这一列显示mysql实际采用哪个索引来优化对该表的访问。 

  如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。

-  **key_len列** 

  这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。

  key_len计算规则如下： 

  - 字符串，char(n)和varchar(n)，5.0.3以后版本中，**n均代表字符数，而不是字节数，**如果是utf-8，一个数字 或字母占1个字节，一个汉字占3个字节 

    - char(n)：如果存汉字长度就是 3n 字节 

    - varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为 varchar是变长字符串 

  - 数值类型

    - tinyint：1字节 
  - smallint：2字节 
    - int：4字节 
  - bigint：8字节
  
- 时间类型
  
  - date：3字节
  
  - timestamp：4字节 
  
  - datetime：8字节 
  
- 如果字段允许为 NULL，需要1字节记录是否为 NULL 
  
  索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。
  
-  **ref列** 

  这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名

-  **rows列** 

  这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。

- **Extra列** 

  这一列展示的是额外信息。常见的重要值如下：

  - **Using index**：使用覆盖索引

    **覆盖索引定义**：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中 获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个 查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。

  - **Using where**：使用 where 语句来处理结果，并且查询的列未被索引覆盖

  - **Using index condition**：查询的列不完全被索引覆盖，where条件中是一个前导列的范围； 

  - **Using temporary**：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索 引来优化。 

  - **Using filesort**：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一 般也是要考虑使用索引来优化的。 

  - **Select tables optimized away**：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是 


### 3.2 回表查询

辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记录，通常情况下，需要扫描两遍索引树，先通过辅助索引定位主键值，然后再通过聚簇索引定位行纪录，这就是回表查询。

###  3.3 覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点:

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

### 3.4 最左前缀原则

复合索引使用时遵循最左前缀原则，最左前缀顾名思义，就是最左优先，查询中使用到最左边的列，那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。

联合索引第一个字段就用范围查找不会走索引，mysql内部可能觉得第一个字段就用范围，结果集应该很大，回表效率不高，还不如就全表扫描 

### 3.5 Like查询



## 一般性建议

1. 对于单键索引，尽量选择针对当前query过滤性更好的索引。
2. 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
3. 在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引
4. 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的
5. 永远小表驱动大表
6. order by子句，尽量使用index方式排序，避免使用filesort方式排序
7. 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀
8. 如果不在索引列上，filesort有两种算法：双路排序和单路排序，增大sort_buffer_size参数设置、增大max_length_for_sort_data参数的设置
9. group by实质是先排序后进行分组，遵照索引建的最佳左欠债

