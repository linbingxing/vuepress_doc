---
title: JVM相关知识体系详解
date: 2021-11-30 07:46:03
permalink: /pages/af6ef9/
categories:
  - Java
  - JVM
tags:
  - #  
---

#  JVM相关知识体系详解

##  第一章 什么是JVM

### 1. 什么是JVM

JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的 。

**目前主流虚拟机**

| 虚拟机名称 | 介绍                                                         |
| ---------- | ------------------------------------------------------------ |
| HotSpot    | Oracle/Sun JDK和OpenJDK都使用HotSPot VM的相同核心            |
| J9         | J9是IBM开发的高度模块化的JVM                                 |
| JRockit    | JRockit 与 HotSpot 同属于 Oracle，目前为止 Oracle 一直在推进 HotSpot 与 JRockit 两款各有优势的虚拟机进行融合互补 |
| Zing       | 由Azul Systems根据HostPot为基础改进的高性能低延迟的JVM       |
| Dalvik     | Android上的Dalvik 虽然名字不叫JVM，但骨子里就是不折不扣的JVM |

### 2. JVM与操作系统

> 为什么要在程序和操作系统中间添加一个JVM

Java 是一门抽象程度特别高的语言，提供了自动内存管理等一系列的特性。这些特性直接在操作系统上实现是不太可能的，所以就需要 JVM 进行一番转换。  

![jvm-1](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-1.jpg)

从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文
件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。

而 Java 跨平台的意义在于一次编译，处处运行，能够做到这一点 JVM 功不可没。比如我们在 Maven 仓库下载同一版本的 jar 包就可以到处运行，不需要在每个平台上再编译一次。

现在的一些 JVM 的扩展语言，比如 Clojure、JRuby、Groovy 等，编译到最后都是 .class 文件，Java 语言的维护
者，只需要控制好 JVM 这个解析器，就可以将这些扩展语言无缝的运行在 JVM 之上了。  

**应用程序、JVM、操作系统的关系**

用一句话概括 JVM 与操作系统之间的关系：JVM 上承开发语言，下接操作系统，它的中间接口就是字节码。

![jvm-2](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-2.jpg)

  ###  3. JVM、JRE、JDK的关系

![jvm-3](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-3.jpg)

JVM是Java程序能够运行的核心。

但是需要注意，JVM 自己什么也干不了，你需要给它提供生产原料（.class 文件） 。

仅仅是 JVM，是无法完成一次编译，处处运行的。它需要一个基本的类库，比如怎么操作文件、怎么连接网络等。

而 Java 体系很慷慨，会一次性将 JVM 运行所需的类库都传递给它。JVM 标准加上实现的一大堆基础类库，就组成
了 Java 的运行时环境，也就是我们常说的 JRE（Java Runtime Environment）。

对于 JDK 来说，就更庞大了一些。除了 JRE，JDK 还提供了一些非常好用的小工具，比如 javac、java、jar 等。它
是 Java 开发的核心，让外行也可以炼剑！

我们也可以看下 JDK 的全拼，Java Development Kit。我非常怕 kit（装备）这个单词，它就像一个无底洞，预示着你永无休止的对它进行研究。JVM、JRE、JDK 它们三者之间的关系，可以用一个包含关系表示。  

![jvm-4](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-4.jpg)

###  4 . JVM虚拟机规范与Java语言规范的关系

广义上来讲，JVM 是一种规范，它是最为官方、最为准确的文档；

狭义上来讲，由于我们使用 Hotspot 更多一些，我们一般在谈到这个概念时，会将它们等同起来。

![jvm-5](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-5.jpg)

左半部分是 Java 虚拟机规范，其实就是为输入和执行字节码提供一个运行环境。

右半部分是我们常说的 Java 语法规范，比如 switch、for、泛型、lambda 等相关的程序，最终都会编译成字节码。而连接左右两部分的桥梁依然是 Java 的字节码。

###  5. Java代码执行流程

过程如下：Java 文件->编译器>字节码->JVM->机器码。

![jvm-6](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-6.png)

比如下面这段 HelloWorld.java，它遵循的就是 Java 语言规范。其中，我们调用了System.out 等模块，也就是JRE里提供的类库。  

```java
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello World");
	}
}
```

使用 JDK 的工具 javac 进行编译后，会产生 HelloWorld.class 的字节码。  

我们一直在说 Java 字节码是沟通 JVM 与 Java 程序的桥梁，下面使用 javap 来稍微看一下字节码到底长什么样子  .

```shell
0 getstatic #2 <java/lang/System.out> // getstatic 获取静态字段的值
3 ldc #3 <Hello World> // ldc 常量池中的常量值入栈
5 invokevirtual #4 <java/io/PrintStream.println> // invokevirtual 运行时方法绑定调用方法
8 return //void 函数返回
```

Java 虚拟机采用基于栈的架构，其指令由操作码和操作数组成。这些 字节码指令 ，就叫作 opcode。其中，
getstatic、ldc、invokevirtual、return 等，就是 opcode，可以看到是比较容易理解的。

JVM 就是靠解析这些 opcode 和操作数来完成程序的执行的。当我们使用 Java 命令运行 .class 文件的时候，实际上就相当于启动了一个 JVM 进程。  

然后 JVM 会翻译这些字节码，它有两种执行方式。常见的就是解释执行，将 opcode + 操作数翻译成机器代码；另外一种执行方式就是 JIT，也就是我们常说的即时编译，它会在一定条件下将字节码编译成机器码之后再执行。

这些 .class 文件会被加载、存放到 metaspace 中，等待被调用，这里会有一个类加载器的概念。而 JVM 的程序运行，都是在栈上完成的，这和其他普通程序的执行是类似的，同样分为堆和栈。比如我们现在运行到了 main 方法，就会给它分配一个栈帧。当退出方法体时，会弹出相应的栈帧。你会发现，大多数字节码指令，就是不断的对栈帧进行操作。

  

## 第二章  Java虚拟机的内存管理

###  1. JVM整体架构

> 根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。  

![jvm-7](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-7.jpg)

Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。

- **线程私有**：程序计数器、虚拟机栈、本地方法区
- **线程共享**：堆、方法区, 堆外内存（JDK7的永久代或JDK8的元空间、代码缓存）



> JVM分为五大模块： 类装载器子系统 、 运行时数据区 、 执行引擎 、 本地方法接口 和 垃圾收集模块 。  

![jvm-8](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-8.jpg)

###  2. JVM 运行时数据区

#### 2.1 PC程序计数器

程序计数寄存器（**Program Counter Register**）,也叫PC计数器或指令计数器。

程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。  

**作用**

PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。

#### 2.2  **PC寄存器特点**

（1）区别于计算机硬件的pc寄存器，两者不略有不同。计算机用pc寄存器来存放“伪指令”或地址，而相对于虚拟
机，pc寄存器它表现为一块内存，虚拟机的pc寄存器的功能也是存放伪指令，更确切的说存放的是将要执行指令的地址。
（2）当虚拟机正在执行的方法是一个本地（native）方法的时候，jvm的pc寄存器存储的值是undefined。
（3）程序计数器是线程私有的，它的生命周期与线程相同，每个线程都有一个。
（4）此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 

> 问题思考

- **使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**

  Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。
  因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。  

- **PC寄存器为什么会被设定为线程私有的？**

  多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。

### 3. 虚拟机栈

#### 3.1 概述

> Java 虚拟机栈(Java Virtual Machine Stacks)，是线程私有的，生命周期和线程一致。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），用于存储**局部变量表**、**操作数栈**，**动态链接**、**方法出口**等信息。每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 。

**作用**：管理 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

**特点**：

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着**入栈**（进栈/压栈），方法执行结束**出栈**
- **栈不存在垃圾回收问题**

**栈中可能出现的异常**：

Java 虚拟机规范允许 **Java虚拟机栈的大小是动态的或者是固定不变的**

- 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 **StackOverflowError** 异常。

- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个**OutOfMemoryError**异常。

可以通过参数`-Xss`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

-Xss 为jvm启动的每个线程分配的内存大小，默认JDK1.4中是256K，JDK1.5+中是1M
Linux/x64 (64-bit): 1024 KB
macOS (64-bit): 1024 KB
Oracle Solaris/x64 (64-bit): 1024 KB
Windows: The default value depends on virtual memory  

#### 3.2 栈帧

栈帧(Stack Frame)，是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。

![jvm-9](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-9.jpg)

#### 3.3 栈帧内部结构

每个**栈帧**（Stack Frame）中存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）(或称为表达式栈)
- 动态链接（Dynamic Linking）：指向运行时常量池的方法引用
- 方法返回地址（Return Address）：方法正常退出或异常退出的地址
- 一些附加信息

![jvm-10](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-10.jpg)

##### 3.3.1 局部变量表

1. 局部变量表也被称为局部变量数组或者本地变量表。
2. 一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。包括8种基本数据类型、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。  
3.  **大小固定**，局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。
4. **Slot单位**，局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）*所以那些比较小的类型也占用32位内存（如boolean、byte、char、short）*，而double和long为64位数据类型，他们需要两个连续的Slot存储（64位虚拟机中可能只需要一个）。
5. **引用类型**，reference类型（引用类型）虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。
6. **Slot是可以重用的**，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。**Slot对对象的引用会影响GC（要是被引用，将不会被回收）。**
7. **方法返回地址**，returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。

##### 3.3.2 操作数栈

操作数栈(Operand Stack)也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。  

**主要特点**

- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**

- 操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，**此时这个方法的操作数栈是空的**

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 `max_stack` 数据项中

- 栈中的任何一个元素都可以是任意的 Java 数据类型
- - 32bit 的类型占用一个栈单位深度
  - 64bit 的类型占用两个栈单位深度

- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问

- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新 PC 寄存器中下一条需要执行的字节码指令

- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证

- 另外，我们说**Java虚拟机的解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈

**栈顶缓存（Top-of-StackCashing）**

目前主流的JVM，基本都是基于栈式架构的虚拟机：

基于栈的指令集架构

- 设计和实现更简单，适用于资源受限的系统。
- 避开了寄存器的分配难题：**使用零地址指令方式分配。**
- 指令流中的指令**大部分都是零地址的指令**，其**执行过程依赖于操作栈**。**指令集更小，编译器容易实现**。
- 不需要硬件的特殊支持，**可移植性好**，能够更好的实现跨平台。

由于是基于栈的架构，零地址指令方式，所以也有相应的缺点：**完成同一个操作需要的更多的出栈和入栈指令，这就意味着将需要更多次的指令分派（instruction dispatch）次数以及内存读写次数**。

为了解决或者优化这一问题，Hotspot MV的那些大佬们开发了栈顶缓存技术，**将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**。

> 零地址指令是机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码，没有操作数。 这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器中，指令可直接访问寄存器。

有关栈顶缓存技术需要关注两个核心问题：

- 缓存了栈顶附近的多少个元素？如果缓存了n个元素，那么就叫n-TOS caching；
- 缓存带有多少种“状态”？如果有n种状态那么就叫n-state TOS caching。

##### 3.3.3 动态链接

Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。

![jvm-12](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-12.jpg)

在Java源文件被编译成Class文件时，所有的变量和方法引用都作为符号引用保存在Class文件的常量池中。比如：描述一个方法调用到其他方法时，就是通过常量池中指向方法的符号引用来表示，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

Q: 为什么需要常量池？

A: 字节码文件中需要很多数据的支持，但数据很大，不能直接保存到字节码文件中，所以常量池的作用就是为了提供一些符号和常量，便于指令的识别。

**方法调用**

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定固定机制有关。

- **静态链接**: 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，而且运行期保持不变时，这种情况下将调用方法的符号引用转为直接引用的过程称之为静态链接。
- **动态链接**：如果被调用的方法在编译期无法被确定下来，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，所以称之为动态链接。

对应的方法绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生过一次。

- **早期绑定**：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，由于明确了被调用的目标方法，就可以使用静态链接的方式将符号引用转换为直接引用
- **晚期绑定：**被调用方法在编译时不能被确定下来，只能在运行期根据实际类型绑定相关的方法，这种绑定方式被称为晚期绑定。

**虚方法和非虚方法**

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。

**虚方法表**

在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table)，使用索引表来代替查找。

每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

虚方法表会在类加载的连接阶段被创建并初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。

#####  3.3.4  方法返回地址

方法返回地址是用来存放调用该方法的PC寄存器的值。

一个方法的结束，有两种方式：

- 正常地执行完成

- 出现未处理的异常非正常的退出

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。

当一个方法开始执行后，只有两种方式可以退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定，在字节码指令中，返回指令包含ireturn、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。
2. 在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是说只要在本方法的异常表中没有搜索匹配的异常处理器，就会导致方法退出。方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

正常完成出口和异常完成出口的区别在于：通过异常完成出口退出不会给它的上层调用者产生任何的返回值。

##### 3.3.5 附加信息

栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。  

### 4.  本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其主要区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为了虚拟机使用到的本地（Native)方法服务。

**特点**

1. 本地方法栈加载native方法，native类方法存在的意义在于填补Java代码不方便实现的缺陷而提出的。
2. 是线程私有的，它的生命周期与线程相同，每个线程都有一个。  
3. Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。

在Java虚拟机规范中，对本地方法栈这块区域，与Java虚拟机栈一样，规定了两种类型的异常：

(1) StackOverFlowError :线程请求的栈深度>所允许的深度。

(2) OutOfMemoryError：本地方法栈扩展时无法申请到足够的内存。  



###  5.  堆内存



###  6.  方法区



### 7.  元空间



**参考资料**

[JVM操作数栈之栈顶缓存](https://www.wangt.cc/2021/08/jvm%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B9%8B%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98/)

