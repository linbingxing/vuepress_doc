---
title: JVM相关知识体系详解
date: 2021-11-30 07:46:03
permalink: /pages/af6ef9/
categories:
  - Java
  - JVM
tags:
  - #  
---

#  JVM相关知识体系详解

##  第一章 什么是JVM

### 1. 什么是JVM

JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的 。

**目前主流虚拟机**

| 虚拟机名称 | 介绍                                                         |
| ---------- | ------------------------------------------------------------ |
| HotSpot    | Oracle/Sun JDK和OpenJDK都使用HotSPot VM的相同核心            |
| J9         | J9是IBM开发的高度模块化的JVM                                 |
| JRockit    | JRockit 与 HotSpot 同属于 Oracle，目前为止 Oracle 一直在推进 HotSpot 与 JRockit 两款各有优势的虚拟机进行融合互补 |
| Zing       | 由Azul Systems根据HostPot为基础改进的高性能低延迟的JVM       |
| Dalvik     | Android上的Dalvik 虽然名字不叫JVM，但骨子里就是不折不扣的JVM |

### 2. JVM与操作系统

> 为什么要在程序和操作系统中间添加一个JVM

Java 是一门抽象程度特别高的语言，提供了自动内存管理等一系列的特性。这些特性直接在操作系统上实现是不太可能的，所以就需要 JVM 进行一番转换。  

![jvm-1](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-1.jpg)

从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文
件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。

而 Java 跨平台的意义在于一次编译，处处运行，能够做到这一点 JVM 功不可没。比如我们在 Maven 仓库下载同一版本的 jar 包就可以到处运行，不需要在每个平台上再编译一次。

现在的一些 JVM 的扩展语言，比如 Clojure、JRuby、Groovy 等，编译到最后都是 .class 文件，Java 语言的维护
者，只需要控制好 JVM 这个解析器，就可以将这些扩展语言无缝的运行在 JVM 之上了。  

**应用程序、JVM、操作系统的关系**

用一句话概括 JVM 与操作系统之间的关系：JVM 上承开发语言，下接操作系统，它的中间接口就是字节码。

![jvm-2](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-2.jpg)

  ###  3. JVM、JRE、JDK的关系

![jvm-3](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-3.jpg)

JVM是Java程序能够运行的核心。

但是需要注意，JVM 自己什么也干不了，你需要给它提供生产原料（.class 文件） 。

仅仅是 JVM，是无法完成一次编译，处处运行的。它需要一个基本的类库，比如怎么操作文件、怎么连接网络等。

而 Java 体系很慷慨，会一次性将 JVM 运行所需的类库都传递给它。JVM 标准加上实现的一大堆基础类库，就组成
了 Java 的运行时环境，也就是我们常说的 JRE（Java Runtime Environment）。

对于 JDK 来说，就更庞大了一些。除了 JRE，JDK 还提供了一些非常好用的小工具，比如 javac、java、jar 等。它
是 Java 开发的核心，让外行也可以炼剑！

我们也可以看下 JDK 的全拼，Java Development Kit。我非常怕 kit（装备）这个单词，它就像一个无底洞，预示着你永无休止的对它进行研究。JVM、JRE、JDK 它们三者之间的关系，可以用一个包含关系表示。  

![jvm-4](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-4.jpg)

###  4 . JVM虚拟机规范与Java语言规范的关系

广义上来讲，JVM 是一种规范，它是最为官方、最为准确的文档；

狭义上来讲，由于我们使用 Hotspot 更多一些，我们一般在谈到这个概念时，会将它们等同起来。

![jvm-5](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-5.jpg)

左半部分是 Java 虚拟机规范，其实就是为输入和执行字节码提供一个运行环境。

右半部分是我们常说的 Java 语法规范，比如 switch、for、泛型、lambda 等相关的程序，最终都会编译成字节码。而连接左右两部分的桥梁依然是 Java 的字节码。

###  5. Java代码执行流程

过程如下：Java 文件->编译器>字节码->JVM->机器码。

![jvm-6](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-6.png)

比如下面这段 HelloWorld.java，它遵循的就是 Java 语言规范。其中，我们调用了System.out 等模块，也就是JRE里提供的类库。  

```java
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello World");
	}
}
```

使用 JDK 的工具 javac 进行编译后，会产生 HelloWorld.class 的字节码。  

我们一直在说 Java 字节码是沟通 JVM 与 Java 程序的桥梁，下面使用 javap 来稍微看一下字节码到底长什么样子  .

```shell
0 getstatic #2 <java/lang/System.out> // getstatic 获取静态字段的值
3 ldc #3 <Hello World> // ldc 常量池中的常量值入栈
5 invokevirtual #4 <java/io/PrintStream.println> // invokevirtual 运行时方法绑定调用方法
8 return //void 函数返回
```

Java 虚拟机采用基于栈的架构，其指令由操作码和操作数组成。这些 字节码指令 ，就叫作 opcode。其中，
getstatic、ldc、invokevirtual、return 等，就是 opcode，可以看到是比较容易理解的。

JVM 就是靠解析这些 opcode 和操作数来完成程序的执行的。当我们使用 Java 命令运行 .class 文件的时候，实际上就相当于启动了一个 JVM 进程。  

然后 JVM 会翻译这些字节码，它有两种执行方式。常见的就是解释执行，将 opcode + 操作数翻译成机器代码；另外一种执行方式就是 JIT，也就是我们常说的即时编译，它会在一定条件下将字节码编译成机器码之后再执行。

这些 .class 文件会被加载、存放到 metaspace 中，等待被调用，这里会有一个类加载器的概念。而 JVM 的程序运行，都是在栈上完成的，这和其他普通程序的执行是类似的，同样分为堆和栈。比如我们现在运行到了 main 方法，就会给它分配一个栈帧。当退出方法体时，会弹出相应的栈帧。你会发现，大多数字节码指令，就是不断的对栈帧进行操作。

  

## 第二章  Java虚拟机的内存管理

###  1. JVM整体架构

> 根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。  

![jvm-7](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-7.jpg)

Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。

- **线程私有**：程序计数器、虚拟机栈、本地方法区
- **线程共享**：堆、方法区, 堆外内存（JDK7的永久代或JDK8的元空间、代码缓存）



> JVM分为五大模块： 类装载器子系统 、 运行时数据区 、 执行引擎 、 本地方法接口 和 垃圾收集模块 。  

![jvm-8](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-8.jpg)

###  2. JVM 运行时数据区

#### 2.1 PC程序计数器

程序计数寄存器（**Program Counter Register**）,也叫PC计数器或指令计数器。

程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。  

**作用**

PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。

#### 2.2  **PC寄存器特点**

（1）区别于计算机硬件的pc寄存器，两者不略有不同。计算机用pc寄存器来存放“伪指令”或地址，而相对于虚拟
机，pc寄存器它表现为一块内存，虚拟机的pc寄存器的功能也是存放伪指令，更确切的说存放的是将要执行指令的地址。
（2）当虚拟机正在执行的方法是一个本地（native）方法的时候，jvm的pc寄存器存储的值是undefined。
（3）程序计数器是线程私有的，它的生命周期与线程相同，每个线程都有一个。
（4）此内存区域是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。 

> 问题思考

- **使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**

  Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。
  因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。  

- **PC寄存器为什么会被设定为线程私有的？**

  多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。

### 3. 虚拟机栈

#### 3.1 概述

> Java 虚拟机栈(Java Virtual Machine Stacks)，是线程私有的，生命周期和线程一致。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），用于存储**局部变量表**、**操作数栈**，**动态链接**、**方法出口**等信息。每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 。

**作用**：管理 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

**特点**：

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着**入栈**（进栈/压栈），方法执行结束**出栈**
- **栈不存在垃圾回收问题**

**栈中可能出现的异常**：

Java 虚拟机规范允许 **Java虚拟机栈的大小是动态的或者是固定不变的**

- 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 **StackOverflowError** 异常。

- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个**OutOfMemoryError**异常。

可以通过参数`-Xss`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

-Xss 为jvm启动的每个线程分配的内存大小，默认JDK1.4中是256K，JDK1.5+中是1M
Linux/x64 (64-bit): 1024 KB
macOS (64-bit): 1024 KB
Oracle Solaris/x64 (64-bit): 1024 KB
Windows: The default value depends on virtual memory  

#### 3.2 栈帧

栈帧(Stack Frame)，是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。

![jvm-9](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-9.jpg)

#### 3.3 栈帧内部结构

每个**栈帧**（Stack Frame）中存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）(或称为表达式栈)
- 动态链接（Dynamic Linking）：指向运行时常量池的方法引用
- 方法返回地址（Return Address）：方法正常退出或异常退出的地址
- 一些附加信息

![jvm-10](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-10.jpg)

##### 3.3.1 局部变量表

1. 局部变量表也被称为局部变量数组或者本地变量表。
2. 一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。包括8种基本数据类型、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。  
3.  **大小固定**，局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。
4. **Slot单位**，局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）*所以那些比较小的类型也占用32位内存（如boolean、byte、char、short）*，而double和long为64位数据类型，他们需要两个连续的Slot存储（64位虚拟机中可能只需要一个）。
5. **引用类型**，reference类型（引用类型）虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。
6. **Slot是可以重用的**，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。**Slot对对象的引用会影响GC（要是被引用，将不会被回收）。**
7. **方法返回地址**，returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。

##### 3.3.2 操作数栈

操作数栈(Operand Stack)也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。  

**主要特点**

- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**

- 操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，**此时这个方法的操作数栈是空的**

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 `max_stack` 数据项中

- 栈中的任何一个元素都可以是任意的 Java 数据类型
- - 32bit 的类型占用一个栈单位深度
  - 64bit 的类型占用两个栈单位深度

- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问

- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新 PC 寄存器中下一条需要执行的字节码指令

- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证

- 另外，我们说**Java虚拟机的解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈

**栈顶缓存（Top-of-StackCashing）**

目前主流的JVM，基本都是基于栈式架构的虚拟机：

基于栈的指令集架构

- 设计和实现更简单，适用于资源受限的系统。
- 避开了寄存器的分配难题：**使用零地址指令方式分配。**
- 指令流中的指令**大部分都是零地址的指令**，其**执行过程依赖于操作栈**。**指令集更小，编译器容易实现**。
- 不需要硬件的特殊支持，**可移植性好**，能够更好的实现跨平台。

由于是基于栈的架构，零地址指令方式，所以也有相应的缺点：**完成同一个操作需要的更多的出栈和入栈指令，这就意味着将需要更多次的指令分派（instruction dispatch）次数以及内存读写次数**。

为了解决或者优化这一问题，Hotspot MV的那些大佬们开发了栈顶缓存技术，**将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**。

> 零地址指令是机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码，没有操作数。 这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器中，指令可直接访问寄存器。

有关栈顶缓存技术需要关注两个核心问题：

- 缓存了栈顶附近的多少个元素？如果缓存了n个元素，那么就叫n-TOS caching；
- 缓存带有多少种“状态”？如果有n种状态那么就叫n-state TOS caching。

##### 3.3.3 动态链接

Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。

![jvm-12](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-12.jpg)

在Java源文件被编译成Class文件时，所有的变量和方法引用都作为符号引用保存在Class文件的常量池中。比如：描述一个方法调用到其他方法时，就是通过常量池中指向方法的符号引用来表示，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

Q: 为什么需要常量池？

A: 字节码文件中需要很多数据的支持，但数据很大，不能直接保存到字节码文件中，所以常量池的作用就是为了提供一些符号和常量，便于指令的识别。

**方法调用**

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定固定机制有关。

- **静态链接**: 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，而且运行期保持不变时，这种情况下将调用方法的符号引用转为直接引用的过程称之为静态链接。
- **动态链接**：如果被调用的方法在编译期无法被确定下来，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，所以称之为动态链接。

对应的方法绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生过一次。

- **早期绑定**：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，由于明确了被调用的目标方法，就可以使用静态链接的方式将符号引用转换为直接引用
- **晚期绑定：**被调用方法在编译时不能被确定下来，只能在运行期根据实际类型绑定相关的方法，这种绑定方式被称为晚期绑定。

**虚方法和非虚方法**

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。

**虚方法表**

在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table)，使用索引表来代替查找。

每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

虚方法表会在类加载的连接阶段被创建并初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。

#####  3.3.4  方法返回地址

方法返回地址是用来存放调用该方法的PC寄存器的值。

一个方法的结束，有两种方式：

- 正常地执行完成

- 出现未处理的异常非正常的退出

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。

当一个方法开始执行后，只有两种方式可以退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定，在字节码指令中，返回指令包含ireturn、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。
2. 在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是说只要在本方法的异常表中没有搜索匹配的异常处理器，就会导致方法退出。方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

正常完成出口和异常完成出口的区别在于：通过异常完成出口退出不会给它的上层调用者产生任何的返回值。

##### 3.3.5 附加信息

栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。  

### 4.  本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其主要区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为了虚拟机使用到的本地（Native)方法服务。

**特点**

1. 本地方法栈加载native方法，native类方法存在的意义在于填补Java代码不方便实现的缺陷而提出的。
2. 是线程私有的，它的生命周期与线程相同，每个线程都有一个。  
3. Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。
4. 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任务数量的内存。
5. 允许线程固定或者可动态扩展的内存大小
6. 本地方法是使用C、C++语言实现的
7. 

在Java虚拟机规范中，对本地方法栈这块区域，与Java虚拟机栈一样，规定了两种类型的异常：

(1) StackOverFlowError :线程请求的栈深度>所允许的深度。

(2) OutOfMemoryError：本地方法栈扩展时无法申请到足够的内存。  

###  5.  堆内存

####  5.1 Java堆概念

对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。“几乎“ 是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。

**堆的特点**

1. 是Java虚拟机所管理的内存中最大的一块。
2. 堆是JVM所在线程共享的。
3. 在虚拟机启动的时候创建。
4. 唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。
5. Java堆是垃圾收集器管理的主要区域。
6. 因此很多时候Java堆也被称为“GC堆”。从内存回收的角度来看，由于现在收集器基本上都是采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代又可以分为：Eden空间、From Survivor空间、To Survivor空间。
7. Java堆是计算机物理存储上不连续的、逻辑上是连续的，也是大小可调节的
8. 方法结束后，堆中对象不会马上移出仅仅在垃圾回收的时候才能移除。
9. 如果在堆中没有内存完成实例的分配、并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常。

#### 5.2  Java堆内存划分

为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域：

- 新生代：新对象和没达到一定年龄的对象都在新生代。
- 老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- 元空间（JDK1.8之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存。

Java虚拟机规范规定，Java堆可以是处于物理上不连续的内存空间中，只有逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是扩展的，主流虚拟机都是可以扩展，如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出`OutOfMemoryError` 异常。

#####  5.2.1 年轻代 (Young Generation)

年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分为三个部分——伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为from/to或者s0/s1），默认内存分配比例是8:1:1。

![jvm-13](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-13.jpg)

- 大多数新创建的对象都会位于Eden内存空间中
- 当Eden空间被对象填充时，执行Minor GC，并将所有幸存者对象移动到一个Survivor内存中。
- Minor GC检查幸存者对象时，会将它们移动到另外一个Survivor内存中，所以两个Survivor内存总会有一个是空的。
- Survivor内存的对象经过多次GC循环后存活下来的对象会被移动到老年代，默认为15代。

##### 5.2.2 老年代(Old Generation)

老年代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁。

老年代垃圾收集称为Major GC。

Eden什么条件会进入到老年代呢？

主要有下面三种方式：**大对象，长期存活的对象，动态对象年龄判定**

- 大对象直接进入老年代。比如很长的字符串，或者很大的数组等，参数`-XX:PretenureSizeThreshold=3145728`设置，超过这个参数设置的值就直接进入老年代。
- 长期存活的对象进入老年代。在堆中分配内存的对象，其内存布局的对象头中(Header)包含了 GC 分代年 龄标记信息。如果对象在 eden 区出生，那么它的 GC 分代年龄会初始值为 1，每熬过一次 Minor GC 而不被回收，这个值就会增  加 1 岁。当它的年龄到达一定的数值时，就会晋升到老年代中，可以通过参数-`XX:MaxTenuringThreshold`设置年龄阀值(默认是 15 岁)。
- 当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。

#####  5.2.3 配置堆内存大小

Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 `-Xmx` 和 `-Xms` 来设定。

- -Xms 用来表示堆的起始内存，等价于 -XX:InitialHeapSize
- -Xmx 用来表示堆的最大内存，等价于 -XX:MaxHeapSize
- –XX:NewRatio 用来配置新生代和老年代的比例，默认比例是1:2
- -XX:SurvivorRatio 用来配置Eden和s0、s1的空间占比，默认占比是8:1:1
- -XX:MaxTenuringThreshold 用来配置对象年轻计算器，超过将会被迁移到老年代，默认是15
- -XX:PetenureSizeThreshold 用来配置大对象，超过对象会直接被分配到老年代

一般我们会把-Xms和-Xmx两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能。

#####  5.2.4  对象分配过程

为对象分配内存是一件非常严谨和复杂的任务，JVM的设计者不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，因此还需要考虑GC执行完内存回收后是否存在空间中间产生内存碎片。

1. 新对象先放在Eden区，此区有大小限制
2. 当Eden的空间填满时，当程序需要创建新的对象，JVM的垃圾回收器将对Eden进行垃圾回收（Minor GC），将Eden区中没有被其他对象引用的对象进行销毁，然后再将新的对象放到Eden区。
3. 然后将Eden区中没有被销毁的对象移动到Survivor 0区
4. 如果再次触发垃圾回收，此时上次幸存下来的Survivor 0区没有被回收，就会被移动到Survivor 1区
5. 如果再次经历垃圾回收，此时会重新放回到Survivor 0区，接着再去Survivor 1区
6. 如果累计次数到达默认的15次，这会进入老年区
7. 老年区内存不足时，会再次触发Major GC进行老年区的内存清理
8. 如果老年区执行了Major GC后仍然没有办法进行对象的创建，就会报OOM异常。

![jvm-14](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-14.jpg)

##### 5.2.5  堆GC

JVM中的堆是GC收集垃圾的主要区域。GC分为两种：一种是部分收集器（Partial GC），另外一种是整堆收集器（Full GC）

部分收集器：不是完整收集Java堆的收集器，它可以分为：

- 新生代收集（Minor GC/Young GC): 只是新生代的垃圾收集
- 老年代收集（Major GC/ Old GC)：只是老年代的垃圾收集（目前只有CMS GC会单独回收老年代）
- 混合收集（Mixed GC）：收集整个新生代以及老年代的垃圾收集（G1 GC会混合回收，Region区域回收）

整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集器。

**年轻代GC触发条件：**

- 年轻代空间不足，就会触发Minor GC，这里的年轻代指的是Eden代满，Survivor不满不会引发GC
- Minor GC会引发STW（Stop the World），暂停其他用户的线程，等垃圾回收接收完，用户的线程才能恢复

**老年代GC触发条件**：

- 老年代空间不足时，会尝试触发Minor GC，如果空间还是不足，则触发Major GC
- 如果触发Major GC，内存仍然不足，则报错OOM
- Major GC的速度比Minor GC慢10倍以上

**Full GC触发条件**：

- 调用System.gc()，系统会执行Full GC，不是立即执行。
- 老年代空间不足。
- 方法区空间不足。
- 通过Minor GC进入老年代，平均大小大于老年代的可用内存

####  5.3 元空间

在JDK1.8之前，HotSpot 虚拟机会把方法区当做永久代来回收。 而从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存，而不是虚拟机内存中。HotSopts取消了永久代，那么是不是也就没有方法区了？当然不是，方法区是一个规范，规范没变，它就一直存在，只不过取代了永久代的是元空间而已。

**存储位置不同：**永久代在物理上是堆的一部分，和新生代、老年代的地址是连续的，而**元空间属于系统本地内存**。

**存储内容不同：**在原来的永久代划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。现在类的元信息存储在元空间，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了。

##### 5.3.1 为什么要废弃永久代、引入元空间？

相比于之前的永久代划分，Oracle为什么要做这样的改进呢？

在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等。**它的大小不容易确定**，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等，-XX:MaxPermSize 指定太小很容易造成永久代内存溢出。

移除永久代是为融合HotSpot VM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代永久代会为GC带来不必要的复杂度，并且回收效率偏低。  

##### 5.3.2 废除永久代的好处

- 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。不会遇到永久代存在时的内存溢出错误。  
- 将运行时常量池从PermGen分离出来，与类的元数据分开，提升类元数据的独立性。 
- 将元数据从PermGen剥离出来到Metaspace，可以提升对元数据的管理同时提升GC效率。   

##### 5.3.3 Metaspace相关参数配置

- XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如
  果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提
  高该值。
- -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。如果没有使用该参数来设置类的元数据的大小，**其最
  大可利用空间是整个系统内存的可用空间**。JVM也可以增加本地内存空间来满足类元数据信息的存储。
  但是如果没有设置最大值，则可能存在bug导致Metaspace的空间在不停的扩展，会导致机器的内存不足；进
  而可能出现swap内存被耗尽；最终导致进程直接被系统直接kill掉。
  如果设置了该参数，当Metaspace剩余空间不足，会抛出：java.lang.OutOfMemoryError: Metaspace space
- -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的
  垃圾收集。
- -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的
  垃圾收集 。

###  6.  方法区

#### 6.1 方法区概念

方法区（Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等数据。

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但简单的实现可能不会选择去进行垃圾收集或者进行压缩”。对HotSpot而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。

 方法区只是JVM规范中定义的一个概念，并没有规定如何去实现它，不同的厂商有不同的实现，而永久代（PermGen)是Hotspot虚拟机特有的概念，Java8的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。

永久代在物理上是堆的一部分，和新生代、老年代地址是连续，而元空间存在于本地内存，这样就不受JVM限制了，也比较不会发现OOM。

**特点**

- 方法区与堆一样是各个线程共享的内存区域
- 方法区在JVM启动的时候就会被创建并且它实例的物理内存空间和Java堆一样都可以不连续
- 方法区的大小跟堆空间一样可以选择固定大小或者动态变化
- 方法区的对象决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出虚拟机同样会跑出OOM异常
- 关闭JVM就会释放这个区域的内存

#### 6.2  方法区结构

方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等。

##### 6.2.1 类型信息

对每个加载的类型信息（类Class、接口Interface、枚举Enum、注解Annotation），JVM必须在方法区中存储以下类型信息：

- 这个类型的完整有效名称（全名=包名.类名）
- 这个类型直接父类的完整有效名（对于Interface或者java.lang.Object，都没有父类）
- 这个类型的修饰符（public、abstract、final的某个子集）
- 这个类型直接接口的一个有序列表

##### 6.2.2 域信息（Field）

域信息，即为类的属性、成员变量

- JVM必须在方法区中保存类所有的成员变量相关信息以及声明顺序
- 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）

#####  6.2.3 方法信息（Method）

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

- 方法名称
- 方法的返回类型（或者void）
- 方法参数的数量和类型（按顺序）
- 方法的修饰符（public、private、protected、static、final、volatile、transient的一个子集）
- 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
- 异常表（abstract 和 native 方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

####  6.3 方法区设置

方法区的大小不必是固定的，JVM可以根据应用的需求动态调整。

> JDK7及以前

- 通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M
- 通过-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器默认是82M
- 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGenSpace。

查看JDK  PermSpace区域默认大小

```shell
jps  #java提供的一个显示当前所有java进程pid的命令
jinfo -flag PermSize  进程号  #查看进程的PermSize初始化空间大小
jinfo -flag MaxPermSize  进程号  #查看PermSize最大空间
```

> JDK8以后

- 元数据区大小可以使用参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 指定。
- 默认值依赖于平台。Windows 下，`-XX:MetaspaceSize` 是 21M，`-XX:MaxMetaspacaSize` 的值是 -1，即没有限制。
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 `OutOfMemoryError:Metaspace`。
- `-XX:MetaspaceSize` ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 `-XX:MetaspaceSize` 的值为20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 `MaxMetaspaceSize`时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 `-XX:MetaspaceSize` 设置为一个相对较高的值。

查看JDK Metaspace

```shell
jps  #查看进程号
jinfo -flag MetaspaceSize 进程号 #查看Metaspace 最大分配内存空间
jinfo -flag MaxMetaspaceSize 进程号  #查看Metaspace最大空间
```

### 7.  元空间

在JDK1.7之前，HotSpot虚拟机把方法区当成永久代来进行垃圾回收。而JDK1.8开始，移除永久代、并把方法区移到元空间，位于本地内存中，而不是虚拟机内存中。HotSpots取消了永久代，那么是不是也就没有了方法区了？当然不是，方法区是只是JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（`PermGen`）是 Hotspot虚拟机特有的概念， JDK1.8 的时候又被元空间（`Metaspace`）取代了，永久代和元空间都可以理解为方法区的落地实现。

#### 7.1  **永久代和元空间有什么不同？**

- 存储位置不同：永久代在物理上是堆的一部分、和新生代、老年代的地址是连续的，而元空间属于本地内存。
- 存储内容不同：在原来的永久代划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。现在类的元信息存储在元空间中，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了。

#### 7.2 **为什么要废除永久代、引入元空间？**

相比于之前的永久代划分，为什么要做这样的改进呢？

- 在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等信息。它的大小不容易确定，因为这其中有很多影响因素，比如类的总数、常量池的大小和方法数量等，`-XX:MaxPermSize`指定大小很容易造成永久代内存溢出。
- 移除永久代是为了融合HosSpot VM和JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。
- 永久代会为GC带来不必要的复杂度，并且回收消息偏低。

#### 7.3 **废除永久代的好处**

- 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。不会遇到永久代存在时容易出现内存溢出错误。
- 将运行时常量池从`PermGen`分离出来，与类的元数据分开，提升类元数据的独立性。
- 将元数据从`PermGen`剥离出来到`Metaspace`，可以提升堆元数据管理同时提升垃圾回收效率。

#### 7.4 **`Metaspace`相关参数**

- `-XX:MetaspaceSize`，设置初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过`MaxMetaspaceSize`时，适当提高该值。
- `-XX:MaxMetaspaceSize`，设置最大空间，默认是没有限制的。如果没有使用该参数来设置类的元数据大小，其最大可利用空间是整个系统内存的可用空间。JVM也可以增加本地内存空间来满足类元数据信息的存储。但是如果没有设置最大值，则可能存在bug导致`Metaspace`的空间在不停扩展，会导致机器的内存不足进而可能出现swap内存被耗尽，最终导致进程直接被系统直接kill掉。如果设置了该参数，当`Metaspace`剩余空间不足，则会抛出异常：`java.lang.OutofMemoryError:Metaspace space`
- `-XX:MinMetaspaceFreeRatio`，在GC之后，最小的`Metaspace`剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 。
- `-XX:MaxMetaspaceFreeRatio`，在GC之后，最大的`Metaspace`剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 。

###  8. 常量池

Java中的常量池有：class常量池、运行时常量池、String常量池。

> 为什么要使用常量池？

避免频繁地创建和销毁对象而影响系统性能，实现对象的共享（字符串常量池）；对于类共用的元数据信息，使用常量池可以共享使用，而不是不同线程、对象都创建一个副本，节省内存开销（class常量池、运行时常量池）。

#### 8.1 Class常量池

一个Java类被编译后，就会形成一份Class文件；Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放编译器生成的各种字面量（Literal）和符号引用（Symbolic References），以及其他类的元信息。每个Class文件都有一个Class常量池。

常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

**字面量（Literal） **

字面量相当于Java语言层面常量的概念，包括：

- 八种基本类型的值
- 文本字符串
- 被声明为final的常量

**符号引用（Symbolic References）**

- 被模块导出或者开发的包

- 类和接口的全限定名
- 字段的名称和描述符
- 方法名称和描述符
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
- 动态调用点和动态常量(Dynamically-Computed Call Site、Dynamically-Computed Constant)

以下面的代码为例：

```java
package basic;

public class ConstantsTest {
    public String name = "Hello World";
    public final int num = 100;

    public ConstantsTest(String name) {
        this.name = name;
    }

    public void info() {
        System.out.println(name);
        System.out.println(num);
    }
}
```

按照上面说的规则，该类的class常量池中包含的常量应该有：

**字面量**

- 字符串：`“Hello World”`
- 被final修饰的基本类型值：`100`

**符号引用**

- 类和接口的全限定名：`basic/ConstantsTest`、`Object`
- 字段的名称和描述符：`basic/ConstantsTest.name:Ljava/lang/String;`、`basic/ConstantsTest.num:I`
- 方法名称和描述符：`java/lang/Object."<init>":()V`（构造方法）、`info`、`java/io/PrintStream.println:(Ljava/lang/String;)V`（第一个print）、`java/io/PrintStream.println:(I)V`（第二个print）等

将类编译出class文件，再用 `javap -v ConstantsTest` 可以看到完整的常量池信息：

```java
Classfile /D:/code_workspaces/target/test-classes/basic/ConstantsTest.class
  Last modified 2022-2-7; size 707 bytes
  MD5 checksum 010382ceeb17b24d0545536a3628f864
  Compiled from "ConstantsTest.java"
public class basic.ConstantsTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
//常量池
Constant pool:
   //方法引用，描述方法名称信息
   #1 = Methodref          #9.#27         // java/lang/Object."<init>":()V
   //字面量
   #2 = String             #28            // Hello World
   //对象字段引用
   #3 = Fieldref           #7.#29         // basic/ConstantsTest.name:Ljava/lang/String;
   #4 = Fieldref           #7.#30         // basic/ConstantsTest.num:I
   #5 = Fieldref           #31.#32        // java/lang/System.out:Ljava/io/PrintStream;
   #6 = Methodref          #33.#34        // java/io/PrintStream.println:(Ljava/lang/String;)V
   //类和接口的全限定名
   #7 = Class              #35            // basic/ConstantsTest
   #8 = Methodref          #33.#36        // java/io/PrintStream.println:(I)V
   #9 = Class              #37            // java/lang/Object
  #10 = Utf8               name
  #11 = Utf8               Ljava/lang/String;
  #12 = Utf8               num
  #13 = Utf8               I
  #14 = Utf8               ConstantValue
  //字面量
  #15 = Integer            100
  #16 = Utf8               <init>
  #17 = Utf8               (Ljava/lang/String;)V
  #18 = Utf8               Code
  #19 = Utf8               LineNumberTable
  #20 = Utf8               LocalVariableTable
  #21 = Utf8               this
  #22 = Utf8               Lbasic/ConstantsTest;
  #23 = Utf8               info
  #24 = Utf8               ()V
  #25 = Utf8               SourceFile
  #26 = Utf8               ConstantsTest.java
  //类名、方法名、方法参数类型、字段名等，被上面所引用
  #27 = NameAndType        #16:#24        // "<init>":()V
  #28 = Utf8               Hello World
  #29 = NameAndType        #10:#11        // name:Ljava/lang/String;
  #30 = NameAndType        #12:#13        // num:I
  #31 = Class              #38            // java/lang/System
  #32 = NameAndType        #39:#40        // out:Ljava/io/PrintStream;
  #33 = Class              #41            // java/io/PrintStream
  #34 = NameAndType        #42:#17        // println:(Ljava/lang/String;)V
  #35 = Utf8               basic/ConstantsTest
  #36 = NameAndType        #42:#43        // println:(I)V
  #37 = Utf8               java/lang/Object
  #38 = Utf8               java/lang/System
  #39 = Utf8               out
  #40 = Utf8               Ljava/io/PrintStream;
  #41 = Utf8               java/io/PrintStream
  #42 = Utf8               println
  #43 = Utf8               (I)V
{
  public java.lang.String name;
    descriptor: Ljava/lang/String;
    flags: ACC_PUBLIC

  public final int num;
    descriptor: I
    flags: ACC_PUBLIC, ACC_FINAL
    ConstantValue: int 100

  public basic.ConstantsTest(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: ldc           #2                  // String Hello World
         7: putfield      #3                  // Field name:Ljava/lang/String;
        10: aload_0
        11: bipush        100
        13: putfield      #4                  // Field num:I
        16: aload_0
        17: aload_1
        18: putfield      #3                  // Field name:Ljava/lang/String;
        21: return
      LineNumberTable:
        line 14: 0
        line 11: 4
        line 12: 10
        line 15: 16
        line 16: 21
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      22     0  this   Lbasic/ConstantsTest;
            0      22     1  name   Ljava/lang/String;

  public void info();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: aload_0
         4: getfield      #3                  // Field name:Ljava/lang/String;
         7: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        10: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
        13: bipush        100
        15: invokevirtual #8                  // Method java/io/PrintStream.println:(I)V
        18: return
      LineNumberTable:
        line 19: 0
        line 20: 10
        line 21: 18
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      19     0  this   Lbasic/ConstantsTest;
}
SourceFile: "ConstantsTest.java"
```

#### 8.2 运行常量池

当加载一个类时，势必要将其Class常量池中的信息加载到内存中，这就是**运行时常量池**，通常存储类元信息的内存叫**方法区**，被该类的所有实例对象所共享引用。

> 编译后的字节码文件包含了类型信息、域信息、方法信息等，通过ClassLoader将字节码文件的常量池中的信息加载到内存中，存储在了方法区的运行时常量池中，可以理解为字节码中的常量池只是文件信息，它想要执行就必须加载到内存中，而Java程序是靠JVM，更具体的来说是JVM的执行引擎来解释执行的，执行引擎在运行常量池中取数据，被加载的字节码常量池中的信息是放到了方法区的运行时常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String**类的**intern()**方法。

> **关于String#intern()**
>
> 在代码中，字符串字面量会被放入一个字符串常量池中，使用String类的intern方法时，首先在字符串常量池中查找是否存在一份equal相等的字符串如果有的话就返回该字符串的引用，没有的话就将它加入到字符串常量池中，所以存在于class中的常量池并非固定不变的，可以用intern方法加入新的。

当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。

#### 8.3 字符串常量池

##### 8.3.1 字符串常量池的实现与本质

在HotSpot VM里是通过 `StringTable` 类来实现常量池的，它是一个hash表，即通过计算String对象的hashcode，决定要将其存储在表中的哪个位置，，默认大小为1009。`StringTable` 在JVM中只有一个实例，被所有的类共享。

在**JDK6.0**中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；

在**JDK7.0**中，StringTable的长度可以通过参数指定：

```java
-XX:StringTableSize=1024
```

如果在类的定义中使用了字符串的字面量，直接赋值拼接，则对应的字面量会被放到字符串常量池中，如下面的代码所示：

```java
public class StringPool {
    public static void main(String[] args) {
        String i = "hello";
        String j = "World";
        String k = "hello" + "World";
        String l = new String("hello");
    }
}
```

类的字节码文件内容如下：

```java
Classfile /D:/code_workspaces/basic/target/test-classes/basic/StringPool.class
  Last modified 2022-2-7; size 841 bytes
  MD5 checksum e969efbe6f1d92c05f63ddbc01fa1915
  Compiled from "StringPool.java"
public class basic.StringPool
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #10.#33        // java/lang/Object."<init>":()V
   #2 = String             #34            // hello
   #3 = String             #35            // World
   #4 = String             #36            // helloWorld
   #5 = Class              #37            // java/lang/String
   #6 = Methodref          #5.#38         // java/lang/String."<init>":(Ljava/lang/String;)V
   #7 = Fieldref           #39.#40        // java/lang/System.out:Ljava/io/PrintStream;
   #8 = Methodref          #41.#42        // java/io/PrintStream.println:(Z)V
   #9 = Class              #43            // basic/StringPool
  #10 = Class              #44            // java/lang/Object
  #11 = Utf8               <init>
  #12 = Utf8               ()V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               LocalVariableTable
  #16 = Utf8               this
  #17 = Utf8               Lbasic/StringPool;
  #18 = Utf8               main
  #19 = Utf8               ([Ljava/lang/String;)V
  #20 = Utf8               args
  #21 = Utf8               [Ljava/lang/String;
  #22 = Utf8               i
  #23 = Utf8               Ljava/lang/String;
  #24 = Utf8               j
  #25 = Utf8               k
  #26 = Utf8               l
  #27 = Utf8               StackMapTable
  #28 = Class              #21            // "[Ljava/lang/String;"
  #29 = Class              #37            // java/lang/String
  #30 = Class              #45            // java/io/PrintStream
  #31 = Utf8               SourceFile
  #32 = Utf8               StringPool.java
  #33 = NameAndType        #11:#12        // "<init>":()V
  #34 = Utf8               hello
  #35 = Utf8               World
  #36 = Utf8               helloWorld
  #37 = Utf8               java/lang/String
  #38 = NameAndType        #11:#46        // "<init>":(Ljava/lang/String;)V
  #39 = Class              #47            // java/lang/System
  #40 = NameAndType        #48:#49        // out:Ljava/io/PrintStream;
  #41 = Class              #45            // java/io/PrintStream
  #42 = NameAndType        #50:#51        // println:(Z)V
  #43 = Utf8               basic/StringPool
  #44 = Utf8               java/lang/Object
  #45 = Utf8               java/io/PrintStream
  #46 = Utf8               (Ljava/lang/String;)V
  #47 = Utf8               java/lang/System
  #48 = Utf8               out
  #49 = Utf8               Ljava/io/PrintStream;
  #50 = Utf8               println
  #51 = Utf8               (Z)V
{
  public basic.StringPool();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 9: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lbasic/StringPool;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=5, args_size=1
         0: ldc           #2                  // String hello
         2: astore_1
         3: ldc           #3                  // String World
         5: astore_2
         6: ldc           #4                  // String helloWorld
         8: astore_3
         9: new           #5                  // class java/lang/String
        12: dup
        13: ldc           #2                  // String hello
        15: invokespecial #6                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
        18: astore        4
        20: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        23: aload_1
        24: aload         4
        26: if_acmpne     33
        29: iconst_1
        30: goto          34
        33: iconst_0
        34: invokevirtual #8                  // Method java/io/PrintStream.println:(Z)V
        37: return
      LineNumberTable:
        line 11: 0
        line 12: 3
        line 13: 6
        line 14: 9
        line 15: 20
        line 16: 37
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      38     0  args   [Ljava/lang/String;
            3      35     1     i   Ljava/lang/String;
            6      32     2     j   Ljava/lang/String;
            9      29     3     k   Ljava/lang/String;
           20      18     4     l   Ljava/lang/String;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 33
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream ]
        frame_type = 255 /* full_frame */
          offset_delta = 0
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream, int ]
}
SourceFile: "StringPool.java"
```

从编译器就可以确定值的变量有i、j、k，而l需要调用虚拟方法，所以是运行期决定的，生成的对象不在常量池里，所以程序执行的结果是false。

##### 8.3.2 字符串常量池的存储位置

- 在**JDK6.0**及之前版本中，String Pool里放的都是字符串常量，这些常量都放在Perm Gen区(也就是方法区)中；

- 在**JDK7.0**中，String Pool里放的实际上是字符串对象的引用，对象的实体存储被转移到堆内存中，这样做是因为方法区存储空间有限，一旦常量池过大会导致OOM。

![jvm-17](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-17.png)

### 9. 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出血。

在JDK 1.4中新加入了NIO（New Input/Output） 类， 引入了一种基于通道（Channel） 与缓冲区 （Buwer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的 `DirectByteBuwer`对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了 在Java堆和Native堆中来回复制数据。  

![jvm-15](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-15.jpg)

![jvm-16](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-16.jpg)

NIO的Buffer提供一个可以直接访问系统物理内存的类--`DirectBuffer`。`DirectBuffer`类继承自`ByteBuffer`，但是和普通的`ByteBuffer`不同。普通的`ByteBuffer`仍然在JVM堆上分配内存，其最大内存受限于最大堆内存。而`DirectBuffer`直接分配在物理内存中，并不占用堆空间。在访问普通的`ByteBuffer`时，系统总是会使用一个“内核缓冲区”进行操作。而`DirectBuffer`所在的位置，就相当于这个“内核缓冲区”，因此，使用`DirectBuffer`是一种更加接近内存底层的方法，所以它比普通的`ByteBuffer`更快。

通过使用堆外内存，有以下好处：

1. 改善堆过大时垃圾回收效率，减少停顿。Full GC时会扫描堆内存，回收效率和堆大小成正比。Native的内存，由OS负责管理和回收。
2. 减少内存在Natvie堆和JVM堆拷贝过程，避免拷贝损耗，降低内存使用。
3. 可突破JVM内存大小限制。



### 10. OutOfMemoryError异常实战

#### 10.1 Java堆溢出

堆内存中主要存放对象、数组等，只要不断地创建这些对象，并且保证 GC Roots 到对象之间有可达路径来避免垃
圾收集回收机制清除这些对象，当这些对象所占空间超过最大堆容量时，就会产生 `OutOfMemoryError` 的异常。堆内存异常示例如下：  

```java
/**
* 设置最大堆最小堆：-Xms20m -Xmx20m
*/
public class HeapOOM {
    
	static class OOMObject {
	}
    public static void main(String[] args) {
		List<OOMObject> oomObjectList = new ArrayList<>();
		while (true) {
			oomObjectList.add(new OOMObject());
		}
	}
}
```

运行后会报异常，在堆栈信息中可以看到  

`java.lang.OutOfMemoryError: Java heap space` 的信息，说明在堆内存空间产生内存溢出的异常。  

新产生的对象最初分配在新生代，新生代满后会进行一次 Minor GC ，如果 Minor GC 后空间不足会把该对象和
新生代满足条件的对象放入老年代，老年代空间不足时会进行 Full GC ，之后如果空间还不足以存放新对象则抛
出 `OutOfMemoryError` 异常。
常见原因：

- 内存中加载的数据过多，如一次从数据库中取出过多数据；
- 集合对对象引用过多且使用完后没有清空；
- 代码中存在死循环或循环产生过多重复对象；
- 堆内存分配不合理  

#### 10.2 虚拟机栈和本地方法栈溢出

由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈， 因此对于HotSpot来说， -Xoss参数（设置本地方法栈大
小） 虽然存在， 但实际上是没有任何效果的， 栈容量只能由-Xss参数来设定。 关于虚拟机栈和本地方法栈， 在
《Java虚拟机规范》 中描述了两种异常：  

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出`StackOverflowError`异常。  
2. 如果虚拟机的栈内存允许动态扩展， 当扩展栈容量无法申请到足够的内存时， 将抛出 `OutOfMemoryError`异
   常。

《Java虚拟机规范》 明确允许Java虚拟机实现自行选择是否支持栈的动态扩展， 而`HotSpot`虚拟机的选择是不支持扩展， 所以除非在创建线程申请内存时就因无法获得足够内存而出现 `OutOfMemoryError`异常， 否则在线程运行时是不会因为扩展而导致内存溢出的， 只会因为栈容量无法容纳新的栈帧而导致`StackOverflowError`异常。 为了验证这点， 我们可以做两个实验， 先将实验范围限制在单线程中操作， 尝试下面两种行为是 否能让`HotSpot`虚拟机产生`OutOfMemoryError`异常： 使用-Xss参数减少栈内存容量。 结果： 抛出`StackOverflowError`异常， 异常出现时输出的堆栈深度相应缩小。 定义了大量的本地变量， 增大此方法帧中本地变量表的长度。 

结果： 抛出`StackOverflowError`异常， 异常出现时输出的堆栈深度相应缩小。 

首先， 对第一种情况进行测试 。

```java
/**
\* VM Args： -Xss128k
*/
public class JavaVMStackSOF {
	private int stackLength = 1;
	public void stackLeak() {
		stackLength++;
		stackLeak();
	} 
    public static void main(String[] args) throws Throwable {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try {
			oom.stackLeak();
		} catch (Throwable e) {
			System.out.println("stack length:" + oom.stackLength);
		throw e;
	}
}
```

运行结果：

```shell
stack length:989
Exception in thread "main" java.lang.StackOverflowError
at com.lagou.unit.JavaVMStackSOFTest02.stackLeak(JavaVMStackSOFTest02.java:9)
at com.lagou.unit.JavaVMStackSOFTest02.stackLeak(JavaVMStackSOFTest02.java:10)
at com.lagou.unit.JavaVMStackSOFTest02.stackLeak(JavaVMStackSOFTest02.java:10)
……后续异常堆栈信息省略
```

对于不同版本的Java虚拟机和不同的操作系统， 栈容量最小值可能会有所限制， 这主要取决于操 作系统内存分页
大小。 譬如上述方法中的参数-Xss128k可以正常用于32位Windows系统下的JDK 6， 但 是如果用于64位Windows系
统下的JDK 11， 则会提示栈容量最小不能低于180K， 而在Linux下这个值则 可能是228K， 如果低于这个最小限
制， HotSpot虚拟器启动时会给出如下提示：

```
The Java thread stack size specified is too small. Specify at least 228k
```

我们继续验证第二种情况， 这次代码就显得有些“丑陋”了， 为了多占局部变量表空间， 不得不定义一长串变量，
具体如代码

```java
/**
 * @author zzm
 */
public class JavaVMStackSOF {
	private static int stackLength = 0;
	public static void test() {
        long unused1, unused2, unused3, unused4, unused5,
        unused6, unused7, unused8, unused9, unused10,
        unused11, unused12, unused13, unused14, unused15,
        unused16, unused17, unused18, unused19, unused20,
        unused21, unused22, unused23, unused24, unused25,
        unused26, unused27, unused28, unused29, unused30,
        unused31, unused32, unused33, unused34, unused35,
        unused36, unused37, unused38, unused39, unused40,
        unused41, unused42, unused43, unused44, unused45,
        unused46, unused47, unused48, unused49, unused50,
        unused51, unused52, unused53, unused54, unused55,
        unused56, unused57, unused58, unused59, unused60,
        unused61, unused62, unused63, unused64, unused65,
        unused66, unused67, unused68, unused69, unused70,
        unused71, unused72, unused73, unused74, unused75,
        unused76, unused77, unused78, unused79, unused80,
        unused81, unused82, unused83, unused84, unused85,
        unused86, unused87, unused88, unused89, unused90,
        unused91, unused92, unused93, unused94, unused95,
        unused96, unused97, unused98, unused99, unused100;
        stackLength ++;
        test();
        unused1 = unused2 = unused3 = unused4 = unused5 =
        unused6 = unused7 = unused8 = unused9 = unused10 =
        unused11 = unused12 = unused13 = unused14 = unused15 =
        unused16 = unused17 = unused18 = unused19 = unused20 =
        unused21 = unused22 = unused23 = unused24 = unused25 =
        unused26 = unused27 = unused28 = unused29 = unused30 =
        unused31 = unused32 = unused33 = unused34 = unused35 =
        unused36 = unused37 = unused38 = unused39 = unused40 =
        unused41 = unused42 = unused43 = unused44 = unused45 =
        unused46 = unused47 = unused48 = unused49 = unused50 =
        unused51 = unused52 = unused53 = unused54 = unused55 =
        unused56 = unused57 = unused58 = unused59 = unused60 =
        unused61 = unused62 = unused63 = unused64 = unused65 =
        unused66 = unused67 = unused68 = unused69 = unused70 =
        unused71 = unused72 = unused73 = unused74 = unused75 =
        unused76 = unused77 = unused78 = unused79 = unused80 =
        unused81 = unused82 = unused83 = unused84 = unused85 =
        unused86 = unused87 = unused88 = unused89 = unused90 =
        unused91 = unused92 = unused93 = unused94 = unused95 =
        unused96 = unused97 = unused98 = unused99 = unused100 = 0;
    } 
    
    public static void main(String[] args) {
		try {
			test();
		}catch (Error e){
			System.out.println("stack length:" + stackLength);
			throw e;
		}
	}
}
```

运行结果：

```shell
stack length:598
Exception in thread "main" java.lang.StackOverflowError
	at com.zuipin.yc.pos.db.JavaVMStackSOF.test(JavaVMStackSOF.java:33)
	at com.zuipin.yc.pos.db.JavaVMStackSOF.test(JavaVMStackSOF.java:34)
……后续异常堆栈信息省略  
```

实验结果表明： 无论是由于栈帧太大还是虚拟机栈容量太小， 当新的栈帧内存无法分配的时候， HotSpot虚拟机抛出的都是StackOverflowError异常。 可是如果在允许动态扩展栈容量大小的虚拟机 上， 相同代码则会导致不一样的情况。 譬如远古时代的Classic虚拟机， 这款虚拟机可以支持动态扩展 栈内存的容量， 在Windows上的JDK 1.0.2运行代码清单2-5的话（如果这时候要调整栈容量就应该改 用-oss参数了） ， 得到的结果是：

```shell
stack length:3716
java.lang.OutOfMemoryError
at org.fenixsoft.oom. JavaVMStackSOF.leak(JavaVMStackSOF.java:27)
at org.fenixsoft.oom. JavaVMStackSOF.leak(JavaVMStackSOF.java:28)
at org.fenixsoft.oom. JavaVMStackSOF.leak(JavaVMStackSOF.java:28)
……后续异常堆栈信息省略
```

可见相同的代码在Classic虚拟机中成功产生了`OutOfMemoryError`而不是`StackOverflowError`异常。 如果测试时不限于单线程， 通过不断建立线程的方式， 在`HotSpot`上也是可以产生内存溢出异常 的， 具体如下代码清单所示。  

但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系， 主要取决于操作系统本身的内存使用状态。 甚至可以说， 在这种情况下， 给每个线程的栈分配的内存越大， 反而越容易产生内存溢出异常。 原因其实不难理解， 操作系统分配给每个进程的内存是有限制的， 譬如32位Windows的单个进程 最大内存限制为2GB。
HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值， 那剩余的内存即为2GB（操作系统
限制） 减去最大堆容量， 再减去最大方法区容量， 由于程序计数器 消耗内存很小， 可以忽略掉， 如果把直接内
存和虚拟机进程本身耗费的内存也去掉的话， 剩下的内存 就由虚拟机栈和本地方法栈来分配了。 因此为每个线程
分配到的栈内存越大， 可以建立的线程数量自然就越少， 建立线程时就越容易把剩下的内存耗尽， 代码如下

**创建线程导致内存溢出异常**  

```java
/**
* VM Args： -Xss2M （这时候不妨设大些， 请在32位系统下运行）
*/
public class JavaVMStackOOM {
	private void dontStop() {
		while (true) {
		}
	} 
    public void stackLeakByThread() {
		while (true) {
			Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                	dontStop();
                }
		    });
			thread.start();
		}
	} 
    public static void main(String[] args) throws Throwable {
		JavaVMStackOOM oom = new JavaVMStackOOM();
		oom.stackLeakByThread();
	}
}
```

####  10.3 运行时常量池和方法区溢出

由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。前面曾经提到HotSpot从JDK7开始逐步“去永久代”的计划，并在JDK8中完全使用元空间来代替永久代的背景故事，在此我们就以测试代码来观察一下，使用“永久代”还是“元空间”来实现方法区，对程序有什么实际的影响。

 String::intern()是一个本地方法， 它的作用是如果字符串常量池中已经包含一个等于此String对象的 字符串， 则返回代表池中这个字符串的String对象的引用； 否则， 会将此String对象包含的字符串添加到常量池中， 并且返回此String对象的引用。 在JDK 6或更早之前的HotSpot虚拟机中， 常量池都是分配在永久代中， 我们可以通过

`-XX:PermSize`和`-XX:MaxPermSize`限制永久代的大小， 即可间接限制其中常量池的容量，

 具体实现如代码清单如下：

> 运行时常量池内存溢出

```java
/**
* VM Args： -XX:PermSize=6M -XX:MaxPermSize=6M
*/
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		// 使用Set保持着常量池引用， 避免Full GC回收常量池行为
		Set<String> set = new HashSet<String>();
		// 在short范围内足以让6MB的PermSize产生OOM了
		short i = 0;
		while (true) {
			set.add(String.valueOf(i++).intern());
		}
	}
}
```

运行结果：

```java
Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
at java.lang.String.intern(Native Method)
at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: 18)
```

从运行结果中可以看到，运行时常量池溢出时，在`OutOfMemoryError`异常后面跟随的提示信息是`PermGen space`，说明运行时常量池的确是属于方法区的一部分。

而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果， 无论是在JDK 7中继续使 

用`-XX：MaxPermSize`参数或者在JDK 8及以上版本使用`-XX:MaxMetaspaceSize`参数把方法区容量同 样限制在6MB， 也都不会重现JDK 6中的溢出异常， 循环将一直进行下去， 永不停歇。 出现这种变 化， 是因为自JDK 7起， 原本存放在永久代的字符串常量池被移至Java堆之中， 所以在JDK 7及以上版本， 限制方法区的容量对该测试用例来说是毫无意义的。 这时候使用`-Xmx`参数限制最大堆到6MB就能 够看到以下两种运行结果之一， 具体取决于哪里的对象分配时产生了溢出。

```java
// OOM异常一：
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
at java.base/java.lang.Integer.toString(Integer.java:440)
at java.base/java.lang.String.valueOf(String.java:3058)
at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:12)

// OOM异常二：
//根据Oracle官方文档，默认情况下，如果Java进程花费98%以上的时间执行GC，并且每次只有不到2%的堆被恢复，则JVM抛出
此错误
Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
at java.lang.Integer.toString(Integer.java:401)
at java.lang.String.valueOf(String.java:3099)
at com.lagou.unit.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:17)
```

> 方法区内存溢出

方法区的其他部分的内容， 方法区的主要职责是用于存放类型的相关信息， 如类名、 访问修饰符、 常量池、 字段描述、 方法描述等。 对于这部分区域的测试， 基本的思路是运行时产 生大量的类去填满方法区， 直到溢出为止。虽然直接使用Java SE API也可以动态产生类（如反射时的 `GeneratedConstructorAccessor`和动态代理等） ， 但在本次实验中操作起来比较麻烦。  

**借助CGLib使得方法区出现内存溢出异常**  

```java
/**
* VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M
*/
public class JavaMethodAreaOOM {
    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
            	public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy)
            throws ThrowException{
            	return proxy.invokeSuper(obj, args);
            }
            });
        enhancer.create();
      } 
    } 
    static class OOMObject {
    }
}
```

在JDK 6中的运行结果 ：

```
Caused by: java.lang.OutOfMemoryError: PermGen space
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)
at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
... 8 more
```

方法区溢出也是一种常见的内存溢出异常， 一个类如果要被垃圾收集器回收， 要达成的条件是比较苛刻的。 在经
常运行时生成大量动态类的应用场景里， 就应该特别关注这些类的回收状况。 这类场 景除了之前提到的程序使用
了CGLib字节码增强和动态语言外， 常见的还有： 大量JSP或动态产生JSP 文件的应用（JSP第一次运行时需要编译
为Java类） 、 基于OSGi的应用（即使是同一个类文件， 被不同 的加载器加载也会视为不同的类） 等。 在JDK 8以后， 永久代便完全退出了历史舞台， 元空间作为其替代者登场。 在默认设置下， 前面列举的那些正常的动态创建新类型的测试用例已经很难再迫使虚拟机产生方法区的溢出异常了。 不过 为了让使用者有预防实际应用里出现类似于上面代码的破坏性的操作， HotSpot还是提供了一 些参数作为元空间的防御措施， 主要包括：

-  `-XX:MaxMetaspaceSize`： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存 大小。

- `-XX:MetaspaceSize`： 指定元空间的初始空间大小， 以字节为单位， 达到该值就会触发垃圾收集 进行类型卸载，同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放 了很少的空间， 那么在不超过`-XX:MaxMetaspaceSize`（如果设置了的话） 的情况下， 适当提高该值。
- `-XX:MinMetaspaceFreeRatio`： 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比， 可 减少因为元空间不足导致的垃圾收集的频率。 类似的还有`-XX:MaxMetaspaceFreeRatio`， 用于控制最 大的元空间剩余容量的百分比。  

#### 10.4 直接内存溢出

直接内存（Direct Memory）的容量大小可通过`-XX:MaxDirectMemorySize`参数来指定，如果不去指定，则默认Java堆最大值（由-Xmx指定）一致，越过了`DirectByteBuffer`类直接通过反射获取Unsafe实例进行内存分配

（Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例， 体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能， 在JDK 10时才将Unsafe 的部分功能通过VarHandle开放给外部使用） ，因为虽然使用`DirectByteBuwer`分配内存也会抛出内存溢出异常， 但它抛出异常时并没有真正向操作系统申请分配内存， 而是通过计算得知内存无法分配就会 在代码里手动抛出溢出异常， 真正申请分配内存的方法是`Unsafe::allocateMemory()`  

```java
/**
* VM Args： -Xmx20M -XX:MaxDirectMemorySize=10M
*/
public class DirectMemoryOOM {
	private static final int _1MB = 1024 * 1024;
	public static void main(String[] args) throws Exception {
		Field unsafeField = Unsafe.class.getDeclaredFields()[0];
		unsafeField.setAccessible(true);
		Unsafe unsafe = (Unsafe) unsafeField.get(null);
		while (true) {
			unsafe.allocateMemory(_1MB);
		}
	}
}
```

运行结果：

```
Exception in thread "main" java.lang.OutOfMemoryError
	at sun.misc.Unsafe.allocateMemory(Native Method)
	at com.zuipin.yc.pos.db.DirectMemoryOOM.main(DirectMemoryOOM.java:21)
```

由直接内存导致的内存溢出， 一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常 情况， 如果发现内存溢出之后产生的Dump文件很小， 而程序中又直接或间接使用了 `DirectMemory`（典型的间接使用就是NIO） ，那就可以考虑重点检查一下直接内存方面的原因了。  



## 第三章 虚拟机类加载机制详解

###  1.  类的生命周期

类从被加载到虚拟机内存中开始，到卸载出内存，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）、卸载（Unloading）这7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发送顺序如下图：

图中，加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段不一定，它在某些情况下可以初始化阶段之后在开始，这是为了支持Java语言的运行时绑定（动态绑定）。接下来讲解加载、验证、准备、解析、初始化五个步骤，这五个步骤组成了一个完整的类加载过程。

#### 1.1 加载

加载是类加载的第一个阶段，在加载阶段，虚拟机需要完成以下三件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

虚拟机规范对这三点的要求并不具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如第一条，根本没有指明二进制字节流要从哪里来，怎么来，因此单单就这一条，就能变出许多花样来：

- 从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
- 从网络中获取，这种场景最典型的应用就是Web Applet。
- 运行时计算生成，这种场景使用最多就是动态代理技术，在`java.lang.reflect.Proxy`中，就是用了`ProxyGenerator.generateProxyClass()`来为特定接口生成形式为“*$Proxy"的代理类的二进制字节流。
- 由其他文件生成，典型场景是JSP应用，有JSP文件生成对应的Class文件。
- 从数据库中读取，这种场景比较少见

总而言之，在类加载整个过程中，这部分是对开发中来说可控性最强的一个阶段。

触发类加载的两个时机：

- 预加载

  虚拟机启动时加载，加载的是JAVA_HOME/lib/下的rt.jar下的.class文件，这个jar包里面的内容是程序运行时非常常用到的，像`java.lang.、java.util.、java.io.` 等等，因此随着虚拟机一起加载。要证明这一点很简单，写一个空的main函数，设置虚拟机参数为"`-XX:+TraceClassLoading`"来获取类加载信息，运行一下：  

  ```shell
  [Opened C:\Program Files\Java\jdk1.8.0_171\jre\lib\rt.jar]
  [Loaded java.lang.Object from C:\Program Files\Java\jdk1.8.0_171\jre\lib\rt.jar]
  [Loaded java.io.Serializable from C:\Program Files\Java\jdk1.8.0_171\jre\lib\rt.jar]
  [Loaded java.lang.Comparable from C:\Program Files\Java\jdk1.8.0_171\jre\lib\rt.jar]
  [Loaded java.lang.CharSequence from C:\Program Files\Java\jdk1.8.0_171\jre\lib\rt.jar]
  [Loaded java.lang.reflect.Type from C:\Program Files\Java\jdk1.8.0_171\jre\lib\rt.jar]
  ....
  ```

- 运行时加载

​       虚拟机在用到一个.class文件的时候，会先去内存中查看一下这个.class文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。

#### 1.2 连接

连接包含三个步骤：分别是**验证（Verification）、准备（Preparation）、解析（Resolution）**三个过程。

**验证（Verification）**

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

验证阶段大致会完成4个阶段的检验动作:

- 文件格式验证： 验证字节流是否符合Class文件格式的规范；例如: 是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义分析(注意: 对比`javac`编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了`java.lang.Object`之外。
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

> 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

**准备（Preparation）**

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，**这些内存都将在方法区中分配**。对于该阶段有以下几点需要注意：

- 这时候进行内存分配的仅包括类变量(`static`)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
- 这个阶段赋初始值的变量指的是那些不被final修饰的static变量，比如"public static int value = 123"，value在准备阶段过后是0而不是123，给value赋值为123的动作将在初始化阶段才进行；比如"public static final int value =123;"就不一样了，在准备阶段，虚拟机就会给value赋值为123。  

各个数据类型的零值如下表：  

| 数据类型  | 零值     |
| --------- | -------- |
| int       | 0        |
| long      | 0L       |
| short     | (short)0 |
| chart     | '\u0000' |
| byte      | (byte)0  |
| boolean   | false    |
| float     | 0.of     |
| double    | 0.0d     |
| reference | null     |

**解析（Resolution）**

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。**  

解析动作主要针对类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、

CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、

CONSTANT_Dynamic_info、CONSTANT_InvokeDynamic_info 8种常量类型。

这里需要了解一下符号引用和直接引用有什么区别？

1. 符号引用

   符号引用是一种定义、可以是任何字面上的含义，只要使用时能无歧义地定位到目标即可。

   这个其实是属于编译原理方面的概念、符号引用包括了下面三类常量：

   - 类和接口的全限定名
   - 字段的名称和描述符
   - 方法的名称和描述符

2. 直接引用

   直接引用可以是直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机示例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在内存中了。

#### 1.3  初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:

- 声明类变量是指定初始值
- 使用静态代码块为类变量指定初始值

**JVM初始化步骤**

- 假如这个类还没有被加载和连接，则程序先加载并连接该类
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类
- 假如类中有初始化语句，则系统依次执行这些初始化语句

**类初始化时机**: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:

- 创建类的实例，也就是new的方式
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射(如`Class.forName()`)
- 初始化某个类的子类，则其父类也会被初始化
- Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类

#### 1.4  使用

类访问方法区内的数据结构的接口， 对象是Heap区的数据。

#### 1.5 卸载

**Java虚拟机将结束生命周期的几种情况**

- 执行了System.exit()方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止

###  2. 类加载器

####  2.1  类加载器的作用

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在创建一个`java.lang.Object`对象，用来封装类在方法区内的数据结构。

> 注意：JVM主要在程序第一次主动使用类的时候，才会去加载该类，也就说，JVM并不是在一开始就把一个程序所有的类都加载到内存中，而是到要使用的时候才把它加载进来，而且只加载一次

####  2.2 类加载器的分类

![jvm-18](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-18.png)

**站在Java开发人员的角度来看，类加载器可以大致划分为以下三类** :

- **启动类加载器**: `Bootstrap Class Loader`，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被`Bootstrap ClassLoader`加载)。启动类加载器是无法被Java程序直接引用的。
- **扩展类加载器**：`Extension Class Loader`，该加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。
- **应用程序类加载器**：`Application Class Loader`，该类加载器由`sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径(`ClassPath`)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的`ClassLoader`只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的`ClassLoader`，便可以做到如下几点:

- 在执行非置信代码之前，自动验证数字签名。
- 动态地创建符合用户特定需要的定制化构建类。
- 从特定的场所取得java class，例如数据库中和网络中。

**寻找类加载器**

```java
public class ClassLoaderTest {

    public static void main(String[] args) {
        //获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        //获取系统类加载器的父类加载器，扩展加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);

        //获取扩展加载器的上层启动类加载器，这里会获取不到
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);

        //获取用户自定义类的加载器
        ClassLoader appClassLoder = ClassLoaderTest.class.getClassLoader();
        System.out.println(appClassLoder);

        //获取核心类库使用的启动类加载器
        ClassLoader stringClassLoader = String.class.getClassLoader();
        System.out.println(stringClassLoader);
    }
}
```

运行结果如下：

```java
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@4554617c
null
sun.misc.Launcher$AppClassLoader@18b4aac2
null
```



### 3. 双亲委派模型

#### 3.1 什么是双亲委派模型

双亲委派模式工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（`ClassNotFoudException`)，子加载器才会尝试自己去加载。

#### 3.2 为什么需要双亲委派模型

- 系统类防止内存中出现多份同样的字节码，确保在程序的各种类加载器环境中都能保证是同一个类。
- 保证Java程序安全稳定运行。

#### 3.3 如何实现双亲委派模型

**双亲委派代码实现如下**：

```java
public Class<?> loadClass(String name)throws ClassNotFoundException {
   return loadClass(name, false);
}

protected synchronized Class<?> loadClass(String name, boolean resolve)throws ClassNotFoundException {
            // 首先判断该类型是否已经被加载
            Class c = findLoadedClass(name);
            if (c == null) {
                //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
                try {
                    if (parent != null) {
                         //如果存在父类加载器，就委派给父类加载器加载
                        c = parent.loadClass(name, false);
                    } else {
                    //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
                        c = findBootstrapClass0(name);
                    }
                } catch (ClassNotFoundException e) {
                 // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }

```

###  4. 自定义类加载器

#### 4.1 为什么要自定义加载器

- 隔离加载类
  - 模块隔离,把类加载到不同的应用选中。比如tomcat这类web应用服务器，内部自定义了好几中类加载
    器，用于隔离web应用服务器上的不同应用程序。  
- 修改类的加载方式
  - 除了Bootstrap加载器外，其他的加载并非一定要引入。根据实际情况在某个时间点按需进行动态加载。  
- 扩展加载源
  - 比如还可以从数据库、网络、或其他终端上加载  

- 防止源码泄漏
  - Java代码容易被编译和篡改，可以进行编译加密，类加载需要自定义还原加密字节码。

#### 4.2  自定义类加载器的调用过程

![jvm-19](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-19.jpg)

#### 4.3 自定义类加载器实现

**实现方式：**所有用户自定义类加载器都应该继承`ClassLoader`类，在自定义`ClassLoader`的子类中，通常有两种做法：

1. 重写`loadClass`方法（是实现双亲委派逻辑的地方，修改会破坏双亲委派机制，不推荐）
2. 重写`findClass`方法（推荐使用）

```java
package org.learn.jvm.demo;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;

/**
  * @description TODO
  * @author lbx
  * @date 2022/2/9 10:25
  * @version 1.0.0
 **/
public class MyClassLoader extends ClassLoader {

    private String codePath;

    public MyClassLoader(ClassLoader parent, String codePath) {
        super(parent);
        this.codePath = codePath;
    }

    public MyClassLoader(String codePath) {
        this.codePath = codePath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        BufferedInputStream bis = null;
        ByteArrayOutputStream baos = null;
        try {
            //1.获取字节码路径
            String fileName = codePath+name+".class";
            // 2.获取输入流
            bis = new BufferedInputStream(new FileInputStream(fileName));
            // 3.获取输出流
            baos = new ByteArrayOutputStream();
            // 4.io读写
            int len;
            byte[] data = new byte[1024];
            while ((len=bis.read(data)) != -1){
                baos.write(data,0,len);
            }
            // 5.获取内存中字节数组
            byte[] byteCode = baos.toByteArray();
            // 6.调用defineClass将字节数组转成class对象
            Class<?> defineClass = defineClass(null,byteCode,0,byteCode.length);
            return defineClass;
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            try {
                bis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                baos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return null;
    }


    public static void main(String[] args) throws ClassNotFoundException {
        MyClassLoader classLoader = new MyClassLoader("D:/code_workspaces/java_learn/jvm/jvm-demo/target/classes/org/learn/jvm/demo/");
        Class<?> clazz = classLoader.loadClass("StringPool");
        System.out.println("类加载器是"+clazz.getClassLoader().getClass().getName());
    }
}

```

执行结果如下：

```java
类加载器是org.learn.jvm.demo.MyClassLoader
```

### 5. ClassLoader源码解析

#### 5.1 类的关系图

![jvm-20](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-20.jpg)

![jvm-21](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-21.png)

#### 5.2 Launcher核心类的源码解析

![jvm-22](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-22.jpg)

我们先从启动类说起，有一个`sun.misc.Launcher`类，构造方法主要做了以下事情

- 创建扩展类加载器
- 创建应用程序类加载器
- 设置ContextClassLoader
- 安装安全管理器Security Manager

```java
public class Launcher {
    private static URLStreamHandlerFactory factory = new Launcher.Factory();
    //静态变量,初始化,会执行构造方法
    private static Launcher launcher = new Launcher();
    private static String bootClassPath = System.getProperty("sun.boot.class.path");
    private ClassLoader loader;
    private static URLStreamHandler fileHandler;

    public static Launcher getLauncher() {
        return launcher;
    }
	//构造方法执行
    public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
            //初始化扩展类加载器
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError("Could not create extension class loader", var10);
        }

        try {
            //初始化应用类加载器
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }
        //设置ContextClassLoader，为应用类加载器
        Thread.currentThread().setContextClassLoader(this.loader);
        String var2 = System.getProperty("java.security.manager");
        if (var2 != null) {
            SecurityManager var3 = null;
            if (!"".equals(var2) && !"default".equals(var2)) {
                try {
                    var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();
                } catch (IllegalAccessException var5) {
                    ;
                } catch (InstantiationException var6) {
                    ;
                } catch (ClassNotFoundException var7) {
                    ;
                } catch (ClassCastException var8) {
                    ;
                }
            } else {
                var3 = new SecurityManager();
            }

            if (var3 == null) {
                throw new InternalError("Could not create SecurityManager: " + var2);
            }

            System.setSecurityManager(var3);
        }

    }
}
```



#### 5.3 `ClassLoader`源码解析

`ClassLoader`类，是一个抽象类，其后所有的类加载器都是继承自`ClassLoader`。来看看几个比较重要的方法。

- `loadClass(String)`

  该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用
  该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如
  下，`loadClass(String name, boolean resolve)`是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。  

  ```java
  protected Class<?> loadClass(String name, boolean resolve)
      throws ClassNotFoundException
  {
      synchronized (getClassLoadingLock(name)) {
          // First, check if the class has already been loaded
          // 先从缓存查找该class对象，找到就不用重新加载
          Class<?> c = findLoadedClass(name);
          if (c == null) {
              long t0 = System.nanoTime();
              try {
                  if (parent != null) {
                      //如果找不到，则委托给父类加载器去加载
                      c = parent.loadClass(name, false);
                  } else {
                      //如果没有父类，则委托给启动加载器去加载
                      c = findBootstrapClassOrNull(name);
                  }
              } catch (ClassNotFoundException e) {
                  // ClassNotFoundException thrown if class not found
                  // from the non-null parent class loader
              }
  
              if (c == null) {
                  // If still not found, then invoke findClass in order
                  // to find the class.
                  // 如果都没有找到，则通过自定义实现的findClass去查找并加载
                  long t1 = System.nanoTime();
                  c = findClass(name);
  
                  // this is the defining class loader; record the stats
                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                  sun.misc.PerfCounter.getFindClasses().increment();
              }
          }
          if (resolve) {
              //是否需要在加载时进行解析
              resolveClass(c);
          }
          return c;
      }
  }
  ```

- `findClass(String)`

  ```java
  protected Class<?> findClass(String name) throws ClassNotFoundException {
          throw new ClassNotFoundException(name);
  }
  ```

  在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加
  载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在
  `findClass()`方法中，从前面的分析可知，`findClass()`方法是在`loadClass()`方法中被调用的，当`loadClass()`方法中父加载器加载失败后，则会调用自己的`findClass()`方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是`ClassLoader`类中并没有实现`findClass()`方法的具体代码逻辑，取而代之的是抛出`ClassNotFoundException`异常，同时应该知道的是`findClass`方法通常是和`defineClass`方法一起使用的  

- `defineClass(byte[] b, int ow, int len)`

  `defineClass()`方法是用来将byte字节流解析成JVM能够识别的Class对象(`defineClass`中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象，`defineClass()`方法通常与`findClass()`方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖`ClassLoader`的`findClass()`方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用`defineClass()`方法生成类的Class对象，简单例子如下：  

  ```java
  protected Class<?> findClass(String name) throws ClassNotFoundException {
      // 获取类的字节数组
      byte[] classData = getClassData(name);
      if (classData == null) {
      	throw new ClassNotFoundException();
      } else {
      	//使用defineClass生成class对象
      	return defineClass(name, classData, 0, classData.length);
      }
  }
  ```

  需要注意的是，如果直接调用`defineClass()`方法生成类的Class对象，这个类的Class对象并没有解析(也可以理解为连接阶段，毕竟解析是连接的最后一步)，其解析操作需要等待初始化阶段进行。  

- `resolveClass(Class<?> c)`

  使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，
  为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。



##  第四章  垃圾回收机制及算法

### 1. 垃圾回收概述

> 什么是垃圾回收？

垃圾回收（Garbage Collection，简称GC）是由 Java 虚拟机（JVM）垃圾回收器提供的一种对内存回收的一种机制，它一般会在内存空闲或者内存占用过高的时候对那些没有任何引用的对象不定时地进行回收。

不同于 C++ 程序，C++ 是需要开发人员自己分配内存并且进行自行回收内存的，而 Java 程序，内存是托管于 JVM 的，即对象的创建和内存的回收都是由 JVM 自行完成的，开发人员是无权干涉的，只能尽量去优化。

Java 垃圾回收机制要考虑的问题很复杂，其三个核心问题如下：

- **那些内存需要回收？(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)**
- **什么时候回收？ （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）**
- **如何回收？(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)**

**Java垃圾回收的优缺点**

**优点：**

1. 不需要考虑内存管理  
2. 可以有效的防止内存泄漏，有效的利用可使用的内存  
3. 由于有垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域" 

**缺点：**

开发人员不了解自动内存管理, 内存管理就像一个黑匣子,过度依赖就会降低我们解决内存溢出/内存泄漏等问题
的能力。

###  2. 判断对象是否可回收

#### 2.1 引用计数算法

给每个创建的对象添加一个引用计数器，每当此对象被某个地方引用时，计数值+1，引用失效时-1，所以当计数值为0时表示对象已经不能被使用。引用计数算法大多数情况下是个比较不错的算法，简单直接，也有一些著名的应用案例但是对于Java虚拟机来说，并不是一个好的选择，因为它很难解决对象直接相互循环引用的问题。

**优点：**  

实现简单、执行效率高

**缺点：**

无法检测出循环引用。

譬如有A和B两个对象，他们都互相引用，除此之外都没有任何对外的引用，那么理论上A和B都可以被作为垃
圾回收掉，但实际如果采用引用计数算法，则A、B的引用计数都是1，并不满足被回收的条件，如果A和B之
间的引用一直存在，那么就永远无法被回收了。

```java
public class ReferenceCountingGC {

    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
    }
}
```

#### 2.2 可达性分析算法

##### 2.2.1  可达性分析算法

在主流的商用程序语言如Java、C#等主流实现中，都是通过可达性分析（Reachability Analysis)来判断对象是否存活的。此算法的基本思路就是通过一系列的“GC Roots"的对象作为起始点，从起始点开始向下搜索到对象的路径。搜索所经过的路径称为引用链（Reference Chain），当一个对象到任何GC Roots都没有引用链时，则表明对象“不可达”，即该对象是不可用的。

![jvm-23](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-23.jpg)

Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:

- 虚拟机栈中引用的对象（栈帧中的局部变量表中的reference引用所引用的对象  ）。
- 本地方法栈中JNI（Native方法）引用的对象。
- 方法区中类静态属性引用的对象（static）。
- 方法区中常量引用的对象（final）。
- Java虚拟机内部的引用， 如基本数据类型对应的Class对象， 一些常驻的异常对象（比如 `NullPointExcepiton`、`OutOfMemoryError`） 等， 还有系统类加载器。  
- 所有被同步锁（synchronized关键字） 持有的对象  。
- 反映Java虚拟机内部情况的`JMXBean`、 `JVMTI`中注册的回调、 本地代码缓存等。

![jvm-24](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-24.jpg)

从上图，reference1、reference2、reference3都是GC Roots，可以看出：

- reference1->对象实例1
- reference2->对象实例2
- reference3->对象实例4
- reference3->对象实例4->对象实例6

##### 2.2.2  JVM判断对象是否存活

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于"缓刑"阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。

**第一次标记：**

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行第一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。

**没有必要：**

假如对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过， 那么虚拟机将这两种情况都视为“没有必要执行”。  

**有必要：**

如果这个对象被判定为确有必要执行finalize()方法， 那么该对象将会被放置在一个名为F-Queue的 队列之中， 并在稍后由一条由虚拟机自动建立的、 低调度优先级的Finalizer线程去执行它们的finalize() 方法。  

finalize()方法是对 象逃脱死亡命运的最后一次机会， 稍后收集器将对F-Queue中的对象进行**第二次小规模的标记**， 如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可， 譬如把自己 （this关键字） 赋值给某个类变量或者对象的成员变量， 那在第二次标记时它将被移出“即将回收”的集 合； 如果对象这时候还没有逃脱， 那基本上它就真的要被回收了 。

![jvm-25](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-25.jpg)

##### 2.2.3  引用类型

无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 具有四种强度不同的引用类型。

1. 强引用

   被强引用关联的对象不会被回收。当内存空间不足，Java虚拟机宁愿抛出`OutOfMemoryError`错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  

   使用new一个新对象的方式来创建强引用

   ```java
   Object obj = new Object();
   ```

2. 软引用

   被软引用关联的对象只有在内存不够的情况下才会被回收。软引用可以和一个引用队列（`ReferenceQueue`）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。  

   使用`SoftReference`类来创建软引用。

   ```java
   public static void softRefMemoryEnough(){
           Object obj = new Object();
   
           SoftReference<Object> softReference = new SoftReference<>(obj);
   
           System.out.println(obj);
           System.out.println(softReference.get());
   
           //将对象置空，在内存够用的情况下，按理来说softReference对象是不会被回收的
           obj = null;
           System.gc();
           System.out.println(obj);
           System.out.println(softReference.get());
   }
   
   ```
   
   运行结果如下：
   
   ```
   java.lang.Object@4554617c
   java.lang.Object@4554617c
   null
   java.lang.Object@4554617c
   ```
   
   ```java
   //-Xmx100M  内存不足的情况下，对象会被回收
   public static void softRefMemoryNotEnough() {
       Object o1 = new Object();
       SoftReference<Object> softReference = new SoftReference(o1);
       System.out.println(o1);
       System.out.println(softReference.get());
   
       o1 = null;
       System.gc();
   
       try {
           byte[] bytes = new byte[85 * 1024 * 1024];
       } catch (Throwable e) {
          // e.printStackTrace();
       } finally {
           System.out.println(o1);
           System.out.println(softReference.get());
       }
   }
   ```
   运行结果如下：
   
   ```
   java.lang.Object@4554617c
   java.lang.Object@4554617c
   null
   null
   ```
   
3. 弱引用

   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只 被弱引用关联的对象。  在JDK 1.2版之后提供了`WeakReference`类来实现弱引用。 弱引用可以和一个引用队列（`ReferenceQueue`）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。  

   **弱引用与软引用的区别在于：**

   - 更短暂的生命周期;
   -  一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。  

   使用 `WeakReference` 类来实现弱引用。

   ```java
   public static void weakRefMemoryEnough() {
           Object o1 = new Object();
           //弱引用对象
           WeakReference<Object> weakReference = new WeakReference(o1);
           System.out.println(o1);
           System.out.println(weakReference.get());
   
           o1 = null;
           System.gc();
   
           System.out.println(o1);
           System.out.println(weakReference.get());
    }
   ```
   运行结果如下：

   ```
   java.lang.Object@4554617c
   java.lang.Object@4554617c
   null
   null
   ```

4. 虚引用

   它是最弱的一种引用关系。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动。无法通过虚引用取得一个对象。

   **虚引用与软引用、弱引用的区别：**

   - 虚引用必须和引用队列（`ReferenceQueue`）联合使用。
   - 当垃圾回收器准备回收一个对象时，若发现它还有虚引用，就会回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

   使用 `PhantomReference` 来实现虚引用。有一个叫做cleaner的类，其实就是虚引用典型的应用。可以看到Cleaner是直接简单粗暴的继承了`PhantomReference`，所以它本质上就是一个虚引用，只不过多了一些便捷的操作。

   ```java
   public static void PhantomReferenceTest() throws InterruptedException {
           Object o1 = new Object();
           //开启一个引用队列
           ReferenceQueue<Object> queue = new ReferenceQueue<>();
           //虚引用必须和引用队列一起使用
           PhantomReference<Object> reference = new PhantomReference<>(o1, queue);
   
           System.out.println(o1);
           System.out.println(reference.get());
           //还未回收之前，引用队列是空的
           System.out.println(queue.poll());
   
           System.out.println("================");
           o1 = null;
   
           System.gc();
           Thread.sleep(500);
           System.out.println(o1);
           System.out.println(reference.get());
           //回收之后，回收的对象到了引用队列里
           System.out.println(queue.poll());
   }
   ```
   
   运行结果如下：
   
   ```
   java.lang.Object@4554617c
   null
   null
   ================
   null
   null
   java.lang.ref.PhantomReference@74a14482
   ```

### 3. 垃圾收集算法

#### 3.1  分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

- 弱分代假说（Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡。

一般是把Java堆分为**新生代**和**老年代**。

- 在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用**复制算法**来完成收集。
- 老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记—清除算法**或**标记—整理算法**来进行回收。

| GC算法   | 优点           | 缺点               | 存活对象移动 | 内存碎片 | 适用场景 |
| -------- | -------------- | ------------------ | ------------ | -------- | -------- |
| 引用计数 | 实现简单       | 不能处理循环引用   |              |          |          |
| 标记清除 | 不需要额外空间 | 两次扫描，耗时严重 | N            | Y        | 老年代   |
| 复制     | 没有标记和清除 | 需要额外空间       | Y            | N        | 新生代   |
| 标记整理 | 没有内存碎片   | 需要移动对象的成本 | Y            | N        | 老年代   |

不同分代的名称：

- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集
- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中分为：
  - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
  - 老年代收集（Major GC/ Old GC）：指目标只是老年代的垃圾收集，目前只有CMS收集器会有单独收集老年代的行为。
  - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。

#### 3.2 标记-清除算法（Mark-Sweep）

**标记—清除算法是最基础的收集算法**，它分为“**标记**”和“**清除**”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，**它的标记过程其实就是前面的可达性分析算法中判定垃圾对象的标记过程**。标记—清除算法的执行情况如下图所示：

- 回收前状态

  ![jvm-26](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-26.png)

- 回收后状态

  ![jvm-27](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-27.png)

不足:

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。

#### 3.3 标记-复制算法（Copy）

复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它将可用内存按容量分为大小相等的两块，每次只使用其中的一块，**当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉**。复制算法有如下优点：

- 每次只对一块内存进行回收，运行高效
- 只需移动栈顶指针，按顺序分配内存即可，实现简单
- 内存回收时不用考虑内存碎片的出现

它的缺点是：可一次性分配的**最大内存缩小了一半**

复制算法的执行情况如下图所示：

- 回收前状态

  ![jvm-28](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-28.png)

- 回收后状态

  ![jvm-29](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-29.png)

不足：

- 只使用了内存的一半，总体的GC更加频繁。
- 出现存活对象数量比较多的时候，需要复制较多的对象，成本上升，效率降低。

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。

`HotSpot` 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

#### 3.4 标记-整理算法（Mark-Compact）

复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，**而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存**。标记—整理算法的回收情况如下所示：

- 回收前状态：

  ![jvm-30](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-30.png)

- 回收后状态：

  ![jvm-31](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-31.png)



#### 3.5 分代算法（Generational GC）

#### 3.6 增量算法（Incremental GC）

#### 3.7 并发算法（Concurrent GC）

###  4.  垃圾收集器

#### 4.1 垃圾收集器概述

收集算法是内存回收的方法论，垃圾收集器是算法的落地实现。和回收算法一样，目前还没有完美的收集器，而是根据具体的应用场景选择最合适的收集器，进行分代收集。

#### 4.2 Serial收集器

![jvm-32](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-32.jpg)

Serial收集器，串行垃圾回收，是为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程。

它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。不合适交互性强的服务器环境。

使用方式：`-XX:UseSerialGC`

#### 4.3 ParNew收集器

![jvm-33](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-33.jpg)

ParNew收集器实质上是Serial收集器的多线程并行版本， 除了同时使用多条线程进行垃圾收集之 外， 其余的行为包括Serial收集器可用的所有控制参数 、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一致， 在实现上这两种收集器也共用了相当多的代码。

ParNew收集器在单CPU服务器上的垃圾收集效率绝对不会比Serial收集器高；
但是在多CPU服务器上，效果会明显比Serial好
使用方式：`-XX:+UseParNewGC`
设置线程数: `-XX:ParllGCThreads`  

这里值得一提的是Par是`Parallel（并行）`的缩写，但需要注意的是，这个`并行（Parallel）`仅仅是描述同一时间多条GC线程协同工作，而不是GC线程和用户线程同时运行。ParNew垃圾收集也是需要Stop The World的。

#### 4.4 Parallel Scavengel收集器

Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和ParNew有些类似，但Parallel Scavenge主要关注的是垃圾收集的吞吐量。

所谓吞吐量指的是运行用户代码的时间与处理器总消耗时间的比值。这个比例越高，证明垃圾收集占整个程序运行的比例越小。

![jvm-37](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-37.png)

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量:

- **`-XX：MaxGCPauseMillis`**，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。
  所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。
- **`-XX：GCTimeRatio`**，垃圾收集时间与总时间占比。这个是吞吐量的倒数，原理和`MaxGCPauseMillis`相同。

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。

#### 4.5 Serial Old收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSopt虚拟机使用。

特点：

- 针对老年代
- 采用“标记-整理”算法
- 单线程收集

Serial Old收集器的工作过程如图：

![jvm-34](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-34.jpg)

**设置参数：**`-XX:UseSerialOldGC`

#### 4.6 Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

![jvm-35](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-35.jpg)

**应用场景：**

JDK1.6及以后用来代替老年代的Serial Old收集器；

特别是在Server模式，多CPU的情况下；

在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge+Parallel Old收集器的“给力”应用组合。

**设置参数：**`-XX:UseParallelOldGC`

#### 4.7 CMS收集器

![jvm-36](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-36.jpg)

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用**标记-清除**算法。

CMS收集齐的垃圾收集分为四步：

- `初始标记（CMS initial mark）`：单线程运行，需要Stop The World，标记GC Roots能直达的对象。
- `并发标记（（CMS concurrent mark）`：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。
- `重新标记（CMS remark）`：多线程运行，需要Stop The World，标记并发标记阶段产生对象。
- `并发清除（CMS concurrent sweep）`：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。

**优点：**并发收集、低停顿

**缺点：**

- Mark Sweep算法会导致内存碎片比较多
- CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。
- 并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。

#### 4.8 G1收集器

##### 4.8.1 G1垃圾回收器简介

Garbage First是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。

##### 4.8.2 G1收集器特点

1. G1把内存划分为多个独立的区域Region
2. G1仍然保留分代思想，保留了新生代和老年代，但他们不再是物理隔离，而是一部分Region的集合
3. G1能够充分利用多CPU、多核环境硬件优势，尽量缩短STW
4. G1整体采用标记整理算法，局部是采用复制算法，不会产生内存碎片
5. G1的停顿可预测，能够明确指定在一个时间段内，消耗在垃圾收集上的时间不会超过设置时间
6. G1跟踪各个Region里面垃圾的价值大小，会维护一个优先列表，每次根据允许的时间来回收价值最大的区域，从而保证在有限事件内高效的收集垃圾

##### 4.8.3 Region区域

G1不在坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间，Survivor空间、或者老年代空间。

![jvm-39](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-39.jpg)

将整个堆空间细分为若干个小的区域

- 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。
- 虽然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离的了，它们都是一部分Region的集合。通过Region的动态分配方式实现逻辑上的连续。
- G1收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块，主要用于存储大对象，如果超过1.5个Region，就放到H块中，一般被视为老年代。
- 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

##### 4.8.4 G1 GC过程

G1提供了两种GC模式，Young GC和Mixed GC，两种均是完全Stop The World的。

- Young GC：选定所有年轻代里的Region。通过控制年轻代的Region个数，即年轻代内存大小，来控制Young GC的时间开销。
- Mixed GC：选定所有年轻代里的Region，外加根据Global Concurrent Marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。

![jvm-48](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-48.jpg)

在G1 GC垃圾回收的过程一个有四个阶段：

**初始标记**：标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。

**并发标记**：和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。

**最终标记**：修正并发标记期间，因程序运行导致发生变化的那一部分对象，需要SSTW。

**筛选回收**：根据时间来进行价值最大化收集，制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。

![jvm-38](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-38.png)



###### 4.8.4.1 **G1 Young GC过程**

>  Young GC执行前

堆分为大约2000个区域。最小大小为1Mb，最大大小为32Mb。

![jvm-40](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-40.jpg)

> 执行Young GC

将存活的对象（复制或者移动）到一个或者多个幸存者区域。如果满足老化阈值，则某些对象将被提升到老年代区域。

![jvm-41](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-41.jpg)

> Young GC 结束

![jvm-42](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-42.jpg)

最近升级的对象以深蓝色显示。幸存者区域为绿色。

总而言之，关于G1的年轻一代，可以说以下几点：

- 堆是单个内存空间，分为多个区域。
- 年轻代内存由一组非连续区域组成。
- 年轻一代的垃圾收集器或者年轻的GC出现STW，将停止所有应用程序以进行操作。
- 年轻的GC使用多个线程并行完成。
- 将活动对象复制到新的幸存者或者老年代的地区。

###### 4.8.4.2 G1 Mixed GC过程

**初始标记阶段（Inital Mark，STW）**

存活的对象初始标记背负在年轻的垃圾收集器上。在日志中，此标记为GC  Pause。

![jvm-43](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-43.jpg)

**并发标记阶段（Concurrent Marking）**  

如果找到空白区域（如“ X”所示），则在Remark阶段将其立即删除。另外，计算确定活跃度的信息。  

![jvm-44](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-44.jpg)

**最终标记阶段（Remark，STW）**  

空区域将被删除并回收。现在可以计算所有区域的区域活跃度。  

![jvm-45](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-45.jpg)

**筛选回收阶段/复制清理阶段（Cleanup，STW）**  

G1选择“活度”最低的区域，这些区域可以被最快地收集。然后与年轻的GC同时收集这些区域。这在日志中表示为
[GC pause (mixed)] 。因此，年轻代和老年代都是同时收集的。  

![jvm-46](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-46.jpg)

**筛选回收阶段-(复制/清理)阶段之后**  

选定的区域已被收集并压缩为图中所示的深蓝色区域和深绿色区域。  

![jvm-47](https://gitee.com/linbingxing/image/raw/master/java/srpingcloud/jvm-47.jpg)



总结:

- 并发标记阶段

  - 活动信息是在应用程序运行时同时计算的。

  - 该活动信息标识在疏散暂停期间最适合回收的区域。

  - 像CMS中没有清扫阶段。

- 最终标记阶段
  - 使用开始快照（SATB）算法，该算法比CMS使用的算法快得多。
  - 完全回收空区域。
- 筛选回收阶段
    - 同时回收年轻一代和老一代。
    - 老年代地区是根据其活跃度来选择的。  

##### 4.8.5 G1常用参数

| 参数/默认值                           | 含义                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| -XX:+UseG1GC                          | 使用 G1 垃圾收集器                                           |
| -XX:MaxGCPauseMillis=200              | 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保 证达 |
| -XX:InitiatingHeapOccupancyPercent=45 | mixed gc中也有一个阈值参数 ，当老年代大小占整个堆大小百分 比达到该阈值时，会触发一次mixed gc. 默认值为45 |
| XX:NewRatio=n                         | 新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2. |
| -XX:SurvivorRatio=n                   | eden/survivor 空间大小的比例(Ratio). 默认值为 8.             |
| -XX:MaxTenuringThreshold=n            | 提升年老代的最大临界值(tenuring threshold). 默认值为 15.     |
| -XX:ParallelGCThreads=n               | 设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平 台不同而不同. |
| -XX:ConcGCThreads=n                   | 并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而 不同. |
| XX:G1ReservePercent=n                 | 设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认 值是 10. |
| -XX:G1HeapRegionSize=n                | 使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指 定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值 为 1Mb, 最大值为 32Mb. |

#### 4.9 ZGC收集器

ZGC收集器是一款基于Region内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法，以低延迟为首要目标的一款垃圾收集器。



### 5.  内存分配与回收策略







[新一代垃圾回收器ZGC的探索与实践](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)

[Java11 ZGC 和 Java12 Shenandoah 介绍](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/15%20Java11%20ZGC%20%E5%92%8C%20Java12%20Shenandoah%20%E4%BB%8B%E7%BB%8D%EF%BC%9A%E8%8B%9F%E6%97%A5%E6%96%B0%E3%80%81%E6%97%A5%E6%97%A5%E6%96%B0%E3%80%81%E5%8F%88%E6%97%A5%E6%96%B0.md)

[jvm垃圾回收算法](https://www.cnblogs.com/fnlingnzb-learner/p/13520114.html)

