---
title: JVM相关知识体系详解
date: 2021-11-30 07:46:03
permalink: /pages/af6ef9/
categories:
  - Java
  - JVM
tags:
  - #  
---

#  JVM相关知识体系详解

##  第一章 什么是JVM

### 1. 什么是JVM

JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的 。

**目前主流虚拟机**

| 虚拟机名称 | 介绍                                                         |
| ---------- | ------------------------------------------------------------ |
| HotSpot    | Oracle/Sun JDK和OpenJDK都使用HotSPot VM的相同核心            |
| J9         | J9是IBM开发的高度模块化的JVM                                 |
| JRockit    | JRockit 与 HotSpot 同属于 Oracle，目前为止 Oracle 一直在推进 HotSpot 与 JRockit 两款各有优势的虚拟机进行融合互补 |
| Zing       | 由Azul Systems根据HostPot为基础改进的高性能低延迟的JVM       |
| Dalvik     | Android上的Dalvik 虽然名字不叫JVM，但骨子里就是不折不扣的JVM |

### 2. JVM与操作系统

> 为什么要在程序和操作系统中间添加一个JVM

Java 是一门抽象程度特别高的语言，提供了自动内存管理等一系列的特性。这些特性直接在操作系统上实现是不太可能的，所以就需要 JVM 进行一番转换。  

![jvm-1](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-1.jpg)

从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文
件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。

而 Java 跨平台的意义在于一次编译，处处运行，能够做到这一点 JVM 功不可没。比如我们在 Maven 仓库下载同一版本的 jar 包就可以到处运行，不需要在每个平台上再编译一次。

现在的一些 JVM 的扩展语言，比如 Clojure、JRuby、Groovy 等，编译到最后都是 .class 文件，Java 语言的维护
者，只需要控制好 JVM 这个解析器，就可以将这些扩展语言无缝的运行在 JVM 之上了。  

**应用程序、JVM、操作系统的关系**

用一句话概括 JVM 与操作系统之间的关系：JVM 上承开发语言，下接操作系统，它的中间接口就是字节码。

![jvm-2](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-2.jpg)

  ###  3. JVM、JRE、JDK的关系

![jvm-3](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-3.jpg)

JVM是Java程序能够运行的核心。

但是需要注意，JVM 自己什么也干不了，你需要给它提供生产原料（.class 文件） 。

仅仅是 JVM，是无法完成一次编译，处处运行的。它需要一个基本的类库，比如怎么操作文件、怎么连接网络等。

而 Java 体系很慷慨，会一次性将 JVM 运行所需的类库都传递给它。JVM 标准加上实现的一大堆基础类库，就组成
了 Java 的运行时环境，也就是我们常说的 JRE（Java Runtime Environment）。

对于 JDK 来说，就更庞大了一些。除了 JRE，JDK 还提供了一些非常好用的小工具，比如 javac、java、jar 等。它
是 Java 开发的核心，让外行也可以炼剑！

我们也可以看下 JDK 的全拼，Java Development Kit。我非常怕 kit（装备）这个单词，它就像一个无底洞，预示着你永无休止的对它进行研究。JVM、JRE、JDK 它们三者之间的关系，可以用一个包含关系表示。  

![jvm-4](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-4.jpg)

###  4 . JVM虚拟机规范与Java语言规范的关系

广义上来讲，JVM 是一种规范，它是最为官方、最为准确的文档；

狭义上来讲，由于我们使用 Hotspot 更多一些，我们一般在谈到这个概念时，会将它们等同起来。

![jvm-5](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-5.jpg)

左半部分是 Java 虚拟机规范，其实就是为输入和执行字节码提供一个运行环境。

右半部分是我们常说的 Java 语法规范，比如 switch、for、泛型、lambda 等相关的程序，最终都会编译成字节码。而连接左右两部分的桥梁依然是 Java 的字节码。

###  5. Java代码执行流程

过程如下：Java 文件->编译器>字节码->JVM->机器码。

![jvm-6](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-6.png)

比如下面这段 HelloWorld.java，它遵循的就是 Java 语言规范。其中，我们调用了System.out 等模块，也就是JRE里提供的类库。  

```java
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello World");
	}
}
```

使用 JDK 的工具 javac 进行编译后，会产生 HelloWorld.class 的字节码。  

我们一直在说 Java 字节码是沟通 JVM 与 Java 程序的桥梁，下面使用 javap 来稍微看一下字节码到底长什么样子  .

```shell
0 getstatic #2 <java/lang/System.out> // getstatic 获取静态字段的值
3 ldc #3 <Hello World> // ldc 常量池中的常量值入栈
5 invokevirtual #4 <java/io/PrintStream.println> // invokevirtual 运行时方法绑定调用方法
8 return //void 函数返回
```

Java 虚拟机采用基于栈的架构，其指令由操作码和操作数组成。这些 字节码指令 ，就叫作 opcode。其中，
getstatic、ldc、invokevirtual、return 等，就是 opcode，可以看到是比较容易理解的。

JVM 就是靠解析这些 opcode 和操作数来完成程序的执行的。当我们使用 Java 命令运行 .class 文件的时候，实际上就相当于启动了一个 JVM 进程。  

然后 JVM 会翻译这些字节码，它有两种执行方式。常见的就是解释执行，将 opcode + 操作数翻译成机器代码；另外一种执行方式就是 JIT，也就是我们常说的即时编译，它会在一定条件下将字节码编译成机器码之后再执行。

这些 .class 文件会被加载、存放到 metaspace 中，等待被调用，这里会有一个类加载器的概念。而 JVM 的程序运行，都是在栈上完成的，这和其他普通程序的执行是类似的，同样分为堆和栈。比如我们现在运行到了 main 方法，就会给它分配一个栈帧。当退出方法体时，会弹出相应的栈帧。你会发现，大多数字节码指令，就是不断的对栈帧进行操作。

  

## 第二章  Java虚拟机的内存管理

###  1. JVM整体架构

> 根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。  

![jvm-7](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-7.jpg)

Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。

- **线程私有**：程序计数器、虚拟机栈、本地方法区
- **线程共享**：堆、方法区, 堆外内存（JDK7的永久代或JDK8的元空间、代码缓存）



> JVM分为五大模块： 类装载器子系统 、 运行时数据区 、 执行引擎 、 本地方法接口 和 垃圾收集模块 。  

![jvm-8](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-8.jpg)

###  2. JVM 运行时数据区

#### 2.1 PC程序计数器

程序计数寄存器（**Program Counter Register**）,也叫PC计数器或指令计数器。

程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。  

**作用**

PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。

#### 2.2  **PC寄存器特点**

（1）区别于计算机硬件的pc寄存器，两者不略有不同。计算机用pc寄存器来存放“伪指令”或地址，而相对于虚拟
机，pc寄存器它表现为一块内存，虚拟机的pc寄存器的功能也是存放伪指令，更确切的说存放的是将要执行指令的地址。
（2）当虚拟机正在执行的方法是一个本地（native）方法的时候，jvm的pc寄存器存储的值是undefined。
（3）程序计数器是线程私有的，它的生命周期与线程相同，每个线程都有一个。
（4）此内存区域是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。 

> 问题思考

- **使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**

  Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。
  因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。  

- **PC寄存器为什么会被设定为线程私有的？**

  多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。

### 3. 虚拟机栈

#### 3.1 概述

> Java 虚拟机栈(Java Virtual Machine Stacks)，是线程私有的，生命周期和线程一致。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），用于存储**局部变量表**、**操作数栈**，**动态链接**、**方法出口**等信息。每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 。

**作用**：管理 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

**特点**：

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着**入栈**（进栈/压栈），方法执行结束**出栈**
- **栈不存在垃圾回收问题**

**栈中可能出现的异常**：

Java 虚拟机规范允许 **Java虚拟机栈的大小是动态的或者是固定不变的**

- 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 **StackOverflowError** 异常。

- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个**OutOfMemoryError**异常。

可以通过参数`-Xss`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

-Xss 为jvm启动的每个线程分配的内存大小，默认JDK1.4中是256K，JDK1.5+中是1M
Linux/x64 (64-bit): 1024 KB
macOS (64-bit): 1024 KB
Oracle Solaris/x64 (64-bit): 1024 KB
Windows: The default value depends on virtual memory  

#### 3.2 栈帧

栈帧(Stack Frame)，是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。

![jvm-9](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-9.jpg)

#### 3.3 栈帧内部结构

每个**栈帧**（Stack Frame）中存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）(或称为表达式栈)
- 动态链接（Dynamic Linking）：指向运行时常量池的方法引用
- 方法返回地址（Return Address）：方法正常退出或异常退出的地址
- 一些附加信息

![jvm-10](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-10.jpg)

##### 3.3.1 局部变量表

1. 局部变量表也被称为局部变量数组或者本地变量表。
2. 一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。包括8种基本数据类型、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。  
3.  **大小固定**，局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。
4. **Slot单位**，局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）*所以那些比较小的类型也占用32位内存（如boolean、byte、char、short）*，而double和long为64位数据类型，他们需要两个连续的Slot存储（64位虚拟机中可能只需要一个）。
5. **引用类型**，reference类型（引用类型）虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。
6. **Slot是可以重用的**，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。**Slot对对象的引用会影响GC（要是被引用，将不会被回收）。**
7. **方法返回地址**，returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。

##### 3.3.2 操作数栈

操作数栈(Operand Stack)也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。  

**主要特点**

- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**

- 操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，**此时这个方法的操作数栈是空的**

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 `max_stack` 数据项中

- 栈中的任何一个元素都可以是任意的 Java 数据类型
- - 32bit 的类型占用一个栈单位深度
  - 64bit 的类型占用两个栈单位深度

- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问

- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新 PC 寄存器中下一条需要执行的字节码指令

- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证

- 另外，我们说**Java虚拟机的解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈

**栈顶缓存（Top-of-StackCashing）**

目前主流的JVM，基本都是基于栈式架构的虚拟机：

基于栈的指令集架构

- 设计和实现更简单，适用于资源受限的系统。
- 避开了寄存器的分配难题：**使用零地址指令方式分配。**
- 指令流中的指令**大部分都是零地址的指令**，其**执行过程依赖于操作栈**。**指令集更小，编译器容易实现**。
- 不需要硬件的特殊支持，**可移植性好**，能够更好的实现跨平台。

由于是基于栈的架构，零地址指令方式，所以也有相应的缺点：**完成同一个操作需要的更多的出栈和入栈指令，这就意味着将需要更多次的指令分派（instruction dispatch）次数以及内存读写次数**。

为了解决或者优化这一问题，Hotspot MV的那些大佬们开发了栈顶缓存技术，**将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**。

> 零地址指令是机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码，没有操作数。 这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器中，指令可直接访问寄存器。

有关栈顶缓存技术需要关注两个核心问题：

- 缓存了栈顶附近的多少个元素？如果缓存了n个元素，那么就叫n-TOS caching；
- 缓存带有多少种“状态”？如果有n种状态那么就叫n-state TOS caching。

##### 3.3.3 动态链接

Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。

![jvm-12](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-12.jpg)

在Java源文件被编译成Class文件时，所有的变量和方法引用都作为符号引用保存在Class文件的常量池中。比如：描述一个方法调用到其他方法时，就是通过常量池中指向方法的符号引用来表示，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

Q: 为什么需要常量池？

A: 字节码文件中需要很多数据的支持，但数据很大，不能直接保存到字节码文件中，所以常量池的作用就是为了提供一些符号和常量，便于指令的识别。

**方法调用**

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定固定机制有关。

- **静态链接**: 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，而且运行期保持不变时，这种情况下将调用方法的符号引用转为直接引用的过程称之为静态链接。
- **动态链接**：如果被调用的方法在编译期无法被确定下来，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，所以称之为动态链接。

对应的方法绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生过一次。

- **早期绑定**：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，由于明确了被调用的目标方法，就可以使用静态链接的方式将符号引用转换为直接引用
- **晚期绑定：**被调用方法在编译时不能被确定下来，只能在运行期根据实际类型绑定相关的方法，这种绑定方式被称为晚期绑定。

**虚方法和非虚方法**

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。

**虚方法表**

在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table)，使用索引表来代替查找。

每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

虚方法表会在类加载的连接阶段被创建并初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。

#####  3.3.4  方法返回地址

方法返回地址是用来存放调用该方法的PC寄存器的值。

一个方法的结束，有两种方式：

- 正常地执行完成

- 出现未处理的异常非正常的退出

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。

当一个方法开始执行后，只有两种方式可以退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定，在字节码指令中，返回指令包含ireturn、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。
2. 在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是说只要在本方法的异常表中没有搜索匹配的异常处理器，就会导致方法退出。方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

正常完成出口和异常完成出口的区别在于：通过异常完成出口退出不会给它的上层调用者产生任何的返回值。

##### 3.3.5 附加信息

栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。  

### 4.  本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其主要区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为了虚拟机使用到的本地（Native)方法服务。

**特点**

1. 本地方法栈加载native方法，native类方法存在的意义在于填补Java代码不方便实现的缺陷而提出的。
2. 是线程私有的，它的生命周期与线程相同，每个线程都有一个。  
3. Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。
4. 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任务数量的内存。
5. 允许线程固定或者可动态扩展的内存大小
6. 本地方法是使用C、C++语言实现的
7. 

在Java虚拟机规范中，对本地方法栈这块区域，与Java虚拟机栈一样，规定了两种类型的异常：

(1) StackOverFlowError :线程请求的栈深度>所允许的深度。

(2) OutOfMemoryError：本地方法栈扩展时无法申请到足够的内存。  

###  5.  堆内存

####  5.1 Java堆概念

对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。“几乎“ 是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。

**堆的特点**

1. 是Java虚拟机所管理的内存中最大的一块。
2. 堆是JVM所在线程共享的。
3. 在虚拟机启动的时候创建。
4. 唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。
5. Java堆是垃圾收集器管理的主要区域。
6. 因此很多时候Java堆也被称为“GC堆”。从内存回收的角度来看，由于现在收集器基本上都是采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代又可以分为：Eden空间、From Survivor空间、To Survivor空间。
7. Java堆是计算机物理存储上不连续的、逻辑上是连续的，也是大小可调节的
8. 方法结束后，堆中对象不会马上移出仅仅在垃圾回收的时候才能移除。
9. 如果在堆中没有内存完成实例的分配、并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常。

#### 5.2  Java堆内存划分

为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域：

- 新生代：新对象和没达到一定年龄的对象都在新生代。
- 老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- 元空间（JDK1.8之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存。

Java虚拟机规范规定，Java堆可以是处于物理上不连续的内存空间中，只有逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是扩展的，主流虚拟机都是可以扩展，如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出`OutOfMemoryError` 异常。

#####  5.2.1 年轻代 (Young Generation)

年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分为三个部分——伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为from/to或者s0/s1），默认内存分配比例是8:1:1。

![jvm-13](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-13.jpg)

- 大多数新创建的对象都会位于Eden内存空间中
- 当Eden空间被对象填充时，执行Minor GC，并将所有幸存者对象移动到一个Survivor内存中。
- Minor GC检查幸存者对象时，会将它们移动到另外一个Survivor内存中，所以两个Survivor内存总会有一个是空的。
- Survivor内存的对象经过多次GC循环后存活下来的对象会被移动到老年代，默认为15代。

##### 5.2.2 老年代(Old Generation)

老年代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁。

老年代垃圾收集称为Major GC。

Eden什么条件会进入到老年代呢？

主要有下面三种方式：**大对象，长期存活的对象，动态对象年龄判定**

- 大对象直接进入老年代。比如很长的字符串，或者很大的数组等，参数`-XX:PretenureSizeThreshold=3145728`设置，超过这个参数设置的值就直接进入老年代。
- 长期存活的对象进入老年代。在堆中分配内存的对象，其内存布局的对象头中(Header)包含了 GC 分代年 龄标记信息。如果对象在 eden 区出生，那么它的 GC 分代年龄会初始值为 1，每熬过一次 Minor GC 而不被回收，这个值就会增  加 1 岁。当它的年龄到达一定的数值时，就会晋升到老年代中，可以通过参数-`XX:MaxTenuringThreshold`设置年龄阀值(默认是 15 岁)。
- 当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。

#####  5.2.3 配置堆内存大小

Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 `-Xmx` 和 `-Xms` 来设定。

- -Xms 用来表示堆的起始内存，等价于 -XX:InitialHeapSize
- -Xmx 用来表示堆的最大内存，等价于 -XX:MaxHeapSize
- –XX:NewRatio 用来配置新生代和老年代的比例，默认比例是1:2
- -XX:SurvivorRatio 用来配置Eden和s0、s1的空间占比，默认占比是8:1:1
- -XX:MaxTenuringThreshold 用来配置对象年轻计算器，超过将会被迁移到老年代，默认是15
- -XX:PetenureSizeThreshold 用来配置大对象，超过对象会直接被分配到老年代

一般我们会把-Xms和-Xmx两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能。

#####  5.2.4  对象分配过程

为对象分配内存是一件非常严谨和复杂的任务，JVM的设计者不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，因此还需要考虑GC执行完内存回收后是否存在空间中间产生内存碎片。

1. 新对象先放在Eden区，此区有大小限制
2. 当Eden的空间填满时，当程序需要创建新的对象，JVM的垃圾回收器将对Eden进行垃圾回收（Minor GC），将Eden区中没有被其他对象引用的对象进行销毁，然后再将新的对象放到Eden区。
3. 然后将Eden区中没有被销毁的对象移动到Survivor 0区
4. 如果再次触发垃圾回收，此时上次幸存下来的Survivor 0区没有被回收，就会被移动到Survivor 1区
5. 如果再次经历垃圾回收，此时会重新放回到Survivor 0区，接着再去Survivor 1区
6. 如果累计次数到达默认的15次，这会进入老年区
7. 老年区内存不足时，会再次触发Major GC进行老年区的内存清理
8. 如果老年区执行了Major GC后仍然没有办法进行对象的创建，就会报OOM异常。

![jvm-14](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-14.jpg)

##### 5.2.5  堆GC

JVM中的堆是GC收集垃圾的主要区域。GC分为两种：一种是部分收集器（Partial GC），另外一种是整堆收集器（Full GC）

部分收集器：不是完整收集Java堆的收集器，它可以分为：

- 新生代收集（Minor GC/Young GC): 只是新生代的垃圾收集
- 老年代收集（Major GC/ Old GC)：只是老年代的垃圾收集（目前只有CMS GC会单独回收老年代）
- 混合收集（Mixed GC）：收集整个新生代以及老年代的垃圾收集（G1 GC会混合回收，Region区域回收）

整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集器。

**年轻代GC触发条件：**

- 年轻代空间不足，就会触发Minor GC，这里的年轻代指的是Eden代满，Survivor不满不会引发GC
- Minor GC会引发STW（Stop the World），暂停其他用户的线程，等垃圾回收接收完，用户的线程才能恢复

**老年代GC触发条件**：

- 老年代空间不足时，会尝试触发Minor GC，如果空间还是不足，则触发Major GC
- 如果触发Major GC，内存仍然不足，则报错OOM
- Major GC的速度比Minor GC慢10倍以上

**Full GC触发条件**：

- 调用System.gc()，系统会执行Full GC，不是立即执行。
- 老年代空间不足。
- 方法区空间不足。
- 通过Minor GC进入老年代，平均大小大于老年代的可用内存

####  5.3 元空间

在JDK1.8之前，HotSpot 虚拟机会把方法区当做永久代来回收。 而从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存，而不是虚拟机内存中。HotSopts取消了永久代，那么是不是也就没有方法区了？当然不是，方法区是一个规范，规范没变，它就一直存在，只不过取代了永久代的是元空间而已。

**存储位置不同：**永久代在物理上是堆的一部分，和新生代、老年代的地址是连续的，而**元空间属于系统本地内存**。

**存储内容不同：**在原来的永久代划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。现在类的元信息存储在元空间，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了。

##### 5.3.1 为什么要废弃永久代、引入元空间？

相比于之前的永久代划分，Oracle为什么要做这样的改进呢？

在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等。**它的大小不容易确定**，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等，-XX:MaxPermSize 指定太小很容易造成永久代内存溢出。

移除永久代是为融合HotSpot VM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代永久代会为GC带来不必要的复杂度，并且回收效率偏低。  

##### 5.3.2 废除永久代的好处

- 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。不会遇到永久代存在时的内存溢出错误。  
- 将运行时常量池从PermGen分离出来，与类的元数据分开，提升类元数据的独立性。 
- 将元数据从PermGen剥离出来到Metaspace，可以提升对元数据的管理同时提升GC效率。   

##### 5.3.3 Metaspace相关参数配置

- XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如
  果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提
  高该值。
- -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。如果没有使用该参数来设置类的元数据的大小，**其最
  大可利用空间是整个系统内存的可用空间**。JVM也可以增加本地内存空间来满足类元数据信息的存储。
  但是如果没有设置最大值，则可能存在bug导致Metaspace的空间在不停的扩展，会导致机器的内存不足；进
  而可能出现swap内存被耗尽；最终导致进程直接被系统直接kill掉。
  如果设置了该参数，当Metaspace剩余空间不足，会抛出：java.lang.OutOfMemoryError: Metaspace space
- -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的
  垃圾收集。
- -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的
  垃圾收集 。

###  6.  方法区

#### 6.1 方法区概念

方法区（Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等数据。

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但简单的实现可能不会选择去进行垃圾收集或者进行压缩”。对HotSpot而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。

 方法区只是JVM规范中定义的一个概念，并没有规定如何去实现它，不同的厂商有不同的实现，而永久代（PermGen)是Hotspot虚拟机特有的概念，Java8的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。

永久代在物理上是堆的一部分，和新生代、老年代地址是连续，而元空间存在于本地内存，这样就不受JVM限制了，也比较不会发现OOM。

**特点**

- 方法区与堆一样是各个线程共享的内存区域
- 方法区在JVM启动的时候就会被创建并且它实例的物理内存空间和Java堆一样都可以不连续
- 方法区的大小跟堆空间一样可以选择固定大小或者动态变化
- 方法区的对象决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出虚拟机同样会跑出OOM异常
- 关闭JVM就会释放这个区域的内存

#### 6.2  方法区结构

方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等。

##### 6.2.1 类型信息

对每个加载的类型信息（类Class、接口Interface、枚举Enum、注解Annotation），JVM必须在方法区中存储以下类型信息：

- 这个类型的完整有效名称（全名=包名.类名）
- 这个类型直接父类的完整有效名（对于Interface或者java.lang.Object，都没有父类）
- 这个类型的修饰符（public、abstract、final的某个子集）
- 这个类型直接接口的一个有序列表

##### 6.2.2 域信息（Field）

域信息，即为类的属性、成员变量

- JVM必须在方法区中保存类所有的成员变量相关信息以及声明顺序
- 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）

#####  6.2.3 方法信息（Method）

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

- 方法名称
- 方法的返回类型（或者void）
- 方法参数的数量和类型（按顺序）
- 方法的修饰符（public、private、protected、static、final、volatile、transient的一个子集）
- 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
- 异常表（abstract 和 native 方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

####  6.3 方法区设置

方法区的大小不必是固定的，JVM可以根据应用的需求动态调整。

> JDK7及以前

- 通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M
- 通过-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器默认是82M
- 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGenSpace。

查看JDK  PermSpace区域默认大小

```shell
jps  #java提供的一个显示当前所有java进程pid的命令
jinfo -flag PermSize  进程号  #查看进程的PermSize初始化空间大小
jinfo -flag MaxPermSize  进程号  #查看PermSize最大空间
```

> JDK8以后

- 元数据区大小可以使用参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 指定。
- 默认值依赖于平台。Windows 下，`-XX:MetaspaceSize` 是 21M，`-XX:MaxMetaspacaSize` 的值是 -1，即没有限制。
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 `OutOfMemoryError:Metaspace`。
- `-XX:MetaspaceSize` ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 `-XX:MetaspaceSize` 的值为20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 `MaxMetaspaceSize`时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 `-XX:MetaspaceSize` 设置为一个相对较高的值。

查看JDK Metaspace

```shell
jps  #查看进程号
jinfo -flag MetaspaceSize 进程号 #查看Metaspace 最大分配内存空间
jinfo -flag MaxMetaspaceSize 进程号  #查看Metaspace最大空间
```

### 7.  元空间

在JDK1.7之前，HotSpot虚拟机把方法区当成永久代来进行垃圾回收。而JDK1.8开始，移除永久代、并把方法区移到元空间，位于本地内存中，而不是虚拟机内存中。HotSpots取消了永久代，那么是不是也就没有了方法区了？当然不是，方法区是只是JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（`PermGen`）是 Hotspot虚拟机特有的概念， JDK1.8 的时候又被元空间（`Metaspace`）取代了，永久代和元空间都可以理解为方法区的落地实现。

#### 7.1  **永久代和元空间有什么不同？**

- 存储位置不同：永久代在物理上是堆的一部分、和新生代、老年代的地址是连续的，而元空间属于本地内存。
- 存储内容不同：在原来的永久代划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。现在类的元信息存储在元空间中，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了。

#### 7.2 **为什么要废除永久代、引入元空间？**

相比于之前的永久代划分，为什么要做这样的改进呢？

- 在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等信息。它的大小不容易确定，因为这其中有很多影响因素，比如类的总数、常量池的大小和方法数量等，`-XX:MaxPermSize`指定大小很容易造成永久代内存溢出。
- 移除永久代是为了融合HosSpot VM和JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。
- 永久代会为GC带来不必要的复杂度，并且回收消息偏低。

#### 7.3 **废除永久代的好处**

- 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。不会遇到永久代存在时容易出现内存溢出错误。
- 将运行时常量池从`PermGen`分离出来，与类的元数据分开，提升类元数据的独立性。
- 将元数据从`PermGen`剥离出来到`Metaspace`，可以提升堆元数据管理同时提升垃圾回收效率。

#### 7.4 **`Metaspace`相关参数**

- `-XX:MetaspaceSize`，设置初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过`MaxMetaspaceSize`时，适当提高该值。
- `-XX:MaxMetaspaceSize`，设置最大空间，默认是没有限制的。如果没有使用该参数来设置类的元数据大小，其最大可利用空间是整个系统内存的可用空间。JVM也可以增加本地内存空间来满足类元数据信息的存储。但是如果没有设置最大值，则可能存在bug导致`Metaspace`的空间在不停扩展，会导致机器的内存不足进而可能出现swap内存被耗尽，最终导致进程直接被系统直接kill掉。如果设置了该参数，当`Metaspace`剩余空间不足，则会抛出异常：`java.lang.OutofMemoryError:Metaspace space`
- `-XX:MinMetaspaceFreeRatio`，在GC之后，最小的`Metaspace`剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 。
- `-XX:MaxMetaspaceFreeRatio`，在GC之后，最大的`Metaspace`剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 。

###  8. 常量池

Java中的常量池有：class常量池、运行时常量池、String常量池。

> 为什么要使用常量池？

避免频繁地创建和销毁对象而影响系统性能，实现对象的共享（字符串常量池）；对于类共用的元数据信息，使用常量池可以共享使用，而不是不同线程、对象都创建一个副本，节省内存开销（class常量池、运行时常量池）。

#### 8.1 Class常量池

一个Java类被编译后，就会形成一份Class文件；Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放编译器生成的各种字面量（Literal）和符号引用（Symbolic References），以及其他类的元信息。每个Class文件都有一个Class常量池。

常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

**字面量（Literal） **

字面量相当于Java语言层面常量的概念，包括：

- 八种基本类型的值
- 文本字符串
- 被声明为final的常量

**符号引用（Symbolic References）**

- 被模块导出或者开发的包

- 类和接口的全限定名
- 字段的名称和描述符
- 方法名称和描述符
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
- 动态调用点和动态常量(Dynamically-Computed Call Site、Dynamically-Computed Constant)

以下面的代码为例：

```java
package basic;

public class ConstantsTest {
    public String name = "Hello World";
    public final int num = 100;

    public ConstantsTest(String name) {
        this.name = name;
    }

    public void info() {
        System.out.println(name);
        System.out.println(num);
    }
}
```

按照上面说的规则，该类的class常量池中包含的常量应该有：

**字面量**

- 字符串：`“Hello World”`
- 被final修饰的基本类型值：`100`

**符号引用**

- 类和接口的全限定名：`basic/ConstantsTest`、`Object`
- 字段的名称和描述符：`basic/ConstantsTest.name:Ljava/lang/String;`、`basic/ConstantsTest.num:I`
- 方法名称和描述符：`java/lang/Object."<init>":()V`（构造方法）、`info`、`java/io/PrintStream.println:(Ljava/lang/String;)V`（第一个print）、`java/io/PrintStream.println:(I)V`（第二个print）等

将类编译出class文件，再用 `javap -v ConstantsTest` 可以看到完整的常量池信息：

```java
Classfile /D:/code_workspaces/target/test-classes/basic/ConstantsTest.class
  Last modified 2022-2-7; size 707 bytes
  MD5 checksum 010382ceeb17b24d0545536a3628f864
  Compiled from "ConstantsTest.java"
public class basic.ConstantsTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
//常量池
Constant pool:
   //方法引用，描述方法名称信息
   #1 = Methodref          #9.#27         // java/lang/Object."<init>":()V
   //字面量
   #2 = String             #28            // Hello World
   //对象字段引用
   #3 = Fieldref           #7.#29         // basic/ConstantsTest.name:Ljava/lang/String;
   #4 = Fieldref           #7.#30         // basic/ConstantsTest.num:I
   #5 = Fieldref           #31.#32        // java/lang/System.out:Ljava/io/PrintStream;
   #6 = Methodref          #33.#34        // java/io/PrintStream.println:(Ljava/lang/String;)V
   //类和接口的全限定名
   #7 = Class              #35            // basic/ConstantsTest
   #8 = Methodref          #33.#36        // java/io/PrintStream.println:(I)V
   #9 = Class              #37            // java/lang/Object
  #10 = Utf8               name
  #11 = Utf8               Ljava/lang/String;
  #12 = Utf8               num
  #13 = Utf8               I
  #14 = Utf8               ConstantValue
  //字面量
  #15 = Integer            100
  #16 = Utf8               <init>
  #17 = Utf8               (Ljava/lang/String;)V
  #18 = Utf8               Code
  #19 = Utf8               LineNumberTable
  #20 = Utf8               LocalVariableTable
  #21 = Utf8               this
  #22 = Utf8               Lbasic/ConstantsTest;
  #23 = Utf8               info
  #24 = Utf8               ()V
  #25 = Utf8               SourceFile
  #26 = Utf8               ConstantsTest.java
  //类名、方法名、方法参数类型、字段名等，被上面所引用
  #27 = NameAndType        #16:#24        // "<init>":()V
  #28 = Utf8               Hello World
  #29 = NameAndType        #10:#11        // name:Ljava/lang/String;
  #30 = NameAndType        #12:#13        // num:I
  #31 = Class              #38            // java/lang/System
  #32 = NameAndType        #39:#40        // out:Ljava/io/PrintStream;
  #33 = Class              #41            // java/io/PrintStream
  #34 = NameAndType        #42:#17        // println:(Ljava/lang/String;)V
  #35 = Utf8               basic/ConstantsTest
  #36 = NameAndType        #42:#43        // println:(I)V
  #37 = Utf8               java/lang/Object
  #38 = Utf8               java/lang/System
  #39 = Utf8               out
  #40 = Utf8               Ljava/io/PrintStream;
  #41 = Utf8               java/io/PrintStream
  #42 = Utf8               println
  #43 = Utf8               (I)V
{
  public java.lang.String name;
    descriptor: Ljava/lang/String;
    flags: ACC_PUBLIC

  public final int num;
    descriptor: I
    flags: ACC_PUBLIC, ACC_FINAL
    ConstantValue: int 100

  public basic.ConstantsTest(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: ldc           #2                  // String Hello World
         7: putfield      #3                  // Field name:Ljava/lang/String;
        10: aload_0
        11: bipush        100
        13: putfield      #4                  // Field num:I
        16: aload_0
        17: aload_1
        18: putfield      #3                  // Field name:Ljava/lang/String;
        21: return
      LineNumberTable:
        line 14: 0
        line 11: 4
        line 12: 10
        line 15: 16
        line 16: 21
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      22     0  this   Lbasic/ConstantsTest;
            0      22     1  name   Ljava/lang/String;

  public void info();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: aload_0
         4: getfield      #3                  // Field name:Ljava/lang/String;
         7: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        10: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
        13: bipush        100
        15: invokevirtual #8                  // Method java/io/PrintStream.println:(I)V
        18: return
      LineNumberTable:
        line 19: 0
        line 20: 10
        line 21: 18
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      19     0  this   Lbasic/ConstantsTest;
}
SourceFile: "ConstantsTest.java"
```

#### 8.2 运行常量池

当加载一个类时，势必要将其Class常量池中的信息加载到内存中，这就是**运行时常量池**，通常存储类元信息的内存叫**方法区**，被该类的所有实例对象所共享引用。

> 编译后的字节码文件包含了类型信息、域信息、方法信息等，通过ClassLoader将字节码文件的常量池中的信息加载到内存中，存储在了方法区的运行时常量池中，可以理解为字节码中的常量池只是文件信息，它想要执行就必须加载到内存中，而Java程序是靠JVM，更具体的来说是JVM的执行引擎来解释执行的，执行引擎在运行常量池中取数据，被加载的字节码常量池中的信息是放到了方法区的运行时常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String**类的**intern()**方法。

> **关于String#intern()**
>
> 在代码中，字符串字面量会被放入一个字符串常量池中，使用String类的intern方法时，首先在字符串常量池中查找是否存在一份equal相等的字符串如果有的话就返回该字符串的引用，没有的话就将它加入到字符串常量池中，所以存在于class中的常量池并非固定不变的，可以用intern方法加入新的。

当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。

#### 8.3 字符串常量池

##### 8.3.1 字符串常量池的实现与本质

在HotSpot VM里是通过 `StringTable` 类来实现常量池的，它是一个hash表，即通过计算String对象的hashcode，决定要将其存储在表中的哪个位置，，默认大小为1009。`StringTable` 在JVM中只有一个实例，被所有的类共享。

在**JDK6.0**中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；

在**JDK7.0**中，StringTable的长度可以通过参数指定：

```java
-XX:StringTableSize=1024
```

如果在类的定义中使用了字符串的字面量，直接赋值拼接，则对应的字面量会被放到字符串常量池中，如下面的代码所示：

```java
public class StringPool {
    public static void main(String[] args) {
        String i = "hello";
        String j = "World";
        String k = "hello" + "World";
        String l = new String("hello");
    }
}
```

类的字节码文件内容如下：

```java
Classfile /D:/code_workspaces/basic/target/test-classes/basic/StringPool.class
  Last modified 2022-2-7; size 841 bytes
  MD5 checksum e969efbe6f1d92c05f63ddbc01fa1915
  Compiled from "StringPool.java"
public class basic.StringPool
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #10.#33        // java/lang/Object."<init>":()V
   #2 = String             #34            // hello
   #3 = String             #35            // World
   #4 = String             #36            // helloWorld
   #5 = Class              #37            // java/lang/String
   #6 = Methodref          #5.#38         // java/lang/String."<init>":(Ljava/lang/String;)V
   #7 = Fieldref           #39.#40        // java/lang/System.out:Ljava/io/PrintStream;
   #8 = Methodref          #41.#42        // java/io/PrintStream.println:(Z)V
   #9 = Class              #43            // basic/StringPool
  #10 = Class              #44            // java/lang/Object
  #11 = Utf8               <init>
  #12 = Utf8               ()V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               LocalVariableTable
  #16 = Utf8               this
  #17 = Utf8               Lbasic/StringPool;
  #18 = Utf8               main
  #19 = Utf8               ([Ljava/lang/String;)V
  #20 = Utf8               args
  #21 = Utf8               [Ljava/lang/String;
  #22 = Utf8               i
  #23 = Utf8               Ljava/lang/String;
  #24 = Utf8               j
  #25 = Utf8               k
  #26 = Utf8               l
  #27 = Utf8               StackMapTable
  #28 = Class              #21            // "[Ljava/lang/String;"
  #29 = Class              #37            // java/lang/String
  #30 = Class              #45            // java/io/PrintStream
  #31 = Utf8               SourceFile
  #32 = Utf8               StringPool.java
  #33 = NameAndType        #11:#12        // "<init>":()V
  #34 = Utf8               hello
  #35 = Utf8               World
  #36 = Utf8               helloWorld
  #37 = Utf8               java/lang/String
  #38 = NameAndType        #11:#46        // "<init>":(Ljava/lang/String;)V
  #39 = Class              #47            // java/lang/System
  #40 = NameAndType        #48:#49        // out:Ljava/io/PrintStream;
  #41 = Class              #45            // java/io/PrintStream
  #42 = NameAndType        #50:#51        // println:(Z)V
  #43 = Utf8               basic/StringPool
  #44 = Utf8               java/lang/Object
  #45 = Utf8               java/io/PrintStream
  #46 = Utf8               (Ljava/lang/String;)V
  #47 = Utf8               java/lang/System
  #48 = Utf8               out
  #49 = Utf8               Ljava/io/PrintStream;
  #50 = Utf8               println
  #51 = Utf8               (Z)V
{
  public basic.StringPool();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 9: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lbasic/StringPool;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=5, args_size=1
         0: ldc           #2                  // String hello
         2: astore_1
         3: ldc           #3                  // String World
         5: astore_2
         6: ldc           #4                  // String helloWorld
         8: astore_3
         9: new           #5                  // class java/lang/String
        12: dup
        13: ldc           #2                  // String hello
        15: invokespecial #6                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
        18: astore        4
        20: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        23: aload_1
        24: aload         4
        26: if_acmpne     33
        29: iconst_1
        30: goto          34
        33: iconst_0
        34: invokevirtual #8                  // Method java/io/PrintStream.println:(Z)V
        37: return
      LineNumberTable:
        line 11: 0
        line 12: 3
        line 13: 6
        line 14: 9
        line 15: 20
        line 16: 37
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      38     0  args   [Ljava/lang/String;
            3      35     1     i   Ljava/lang/String;
            6      32     2     j   Ljava/lang/String;
            9      29     3     k   Ljava/lang/String;
           20      18     4     l   Ljava/lang/String;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 33
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream ]
        frame_type = 255 /* full_frame */
          offset_delta = 0
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String, class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream, int ]
}
SourceFile: "StringPool.java"
```

从编译器就可以确定值的变量有i、j、k，而l需要调用虚拟方法，所以是运行期决定的，生成的对象不在常量池里，所以程序执行的结果是false。

##### 8.3.2 字符串常量池的存储位置

- 在**JDK6.0**及之前版本中，String Pool里放的都是字符串常量，这些常量都放在Perm Gen区(也就是方法区)中；

- 在**JDK7.0**中，String Pool里放的实际上是字符串对象的引用，对象的实体存储被转移到堆内存中，这样做是因为方法区存储空间有限，一旦常量池过大会导致OOM。

![jvm-17](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-17.png)

### 9. 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出血。

在JDK 1.4中新加入了NIO（New Input/Output） 类， 引入了一种基于通道（Channel） 与缓冲区 （Buwer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的 `DirectByteBuwer`对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了 在Java堆和Native堆中来回复制数据。  

![jvm-15](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-15.jpg)

![jvm-16](01.JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3.assets/jvm-16.jpg)

NIO的Buffer提供一个可以直接访问系统物理内存的类--`DirectBuffer`。`DirectBuffer`类继承自`ByteBuffer`，但是和普通的`ByteBuffer`不同。普通的`ByteBuffer`仍然在JVM堆上分配内存，其最大内存受限于最大堆内存。而`DirectBuffer`直接分配在物理内存中，并不占用堆空间。在访问普通的`ByteBuffer`时，系统总是会使用一个“内核缓冲区”进行操作。而`DirectBuffer`所在的位置，就相当于这个“内核缓冲区”，因此，使用`DirectBuffer`是一种更加接近内存底层的方法，所以它比普通的`ByteBuffer`更快。

通过使用堆外内存，有以下好处：

1. 改善堆过大时垃圾回收效率，减少停顿。Full GC时会扫描堆内存，回收效率和堆大小成正比。Native的内存，由OS负责管理和回收。
2. 减少内存在Natvie堆和JVM堆拷贝过程，避免拷贝损耗，降低内存使用。
3. 可突破JVM内存大小限制。



### 10. OutOfMemoryError异常实战

#### 10.1 Java堆溢出

堆内存中主要存放对象、数组等，只要不断地创建这些对象，并且保证 GC Roots 到对象之间有可达路径来避免垃
圾收集回收机制清除这些对象，当这些对象所占空间超过最大堆容量时，就会产生 `OutOfMemoryError` 的异常。堆内存异常示例如下：  

```java
/**
* 设置最大堆最小堆：-Xms20m -Xmx20m
*/
public class HeapOOM {
    
	static class OOMObject {
	}
    public static void main(String[] args) {
		List<OOMObject> oomObjectList = new ArrayList<>();
		while (true) {
			oomObjectList.add(new OOMObject());
		}
	}
}
```

运行后会报异常，在堆栈信息中可以看到  

`java.lang.OutOfMemoryError: Java heap space` 的信息，说明在堆内存空间产生内存溢出的异常。  

新产生的对象最初分配在新生代，新生代满后会进行一次 Minor GC ，如果 Minor GC 后空间不足会把该对象和
新生代满足条件的对象放入老年代，老年代空间不足时会进行 Full GC ，之后如果空间还不足以存放新对象则抛
出 `OutOfMemoryError` 异常。
常见原因：

- 内存中加载的数据过多，如一次从数据库中取出过多数据；
- 集合对对象引用过多且使用完后没有清空；
- 代码中存在死循环或循环产生过多重复对象；
- 堆内存分配不合理  

#### 10.2 虚拟机栈和本地方法栈溢出

由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈， 因此对于HotSpot来说， -Xoss参数（设置本地方法栈大
小） 虽然存在， 但实际上是没有任何效果的， 栈容量只能由-Xss参数来设定。 关于虚拟机栈和本地方法栈， 在
《Java虚拟机规范》 中描述了两种异常：  

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出`StackOverflowError`异常。  
2. 如果虚拟机的栈内存允许动态扩展， 当扩展栈容量无法申请到足够的内存时， 将抛出 `OutOfMemoryError`异
   常。

《Java虚拟机规范》 明确允许Java虚拟机实现自行选择是否支持栈的动态扩展， 而`HotSpot`虚拟机的选择是不支持扩展， 所以除非在创建线程申请内存时就因无法获得足够内存而出现 `OutOfMemoryError`异常， 否则在线程运行时是不会因为扩展而导致内存溢出的， 只会因为栈容量无法容纳新的栈帧而导致`StackOverflowError`异常。 为了验证这点， 我们可以做两个实验， 先将实验范围限制在单线程中操作， 尝试下面两种行为是 否能让`HotSpot`虚拟机产生`OutOfMemoryError`异常： 使用-Xss参数减少栈内存容量。 结果： 抛出`StackOverflowError`异常， 异常出现时输出的堆栈深度相应缩小。 定义了大量的本地变量， 增大此方法帧中本地变量表的长度。 

结果： 抛出`StackOverflowError`异常， 异常出现时输出的堆栈深度相应缩小。 

首先， 对第一种情况进行测试 。

```java
/**
\* VM Args： -Xss128k
*/
public class JavaVMStackSOF {
	private int stackLength = 1;
	public void stackLeak() {
		stackLength++;
		stackLeak();
	} 
    public static void main(String[] args) throws Throwable {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try {
			oom.stackLeak();
		} catch (Throwable e) {
			System.out.println("stack length:" + oom.stackLength);
		throw e;
	}
}
```

运行结果：

```shell
stack length:989
Exception in thread "main" java.lang.StackOverflowError
at com.lagou.unit.JavaVMStackSOFTest02.stackLeak(JavaVMStackSOFTest02.java:9)
at com.lagou.unit.JavaVMStackSOFTest02.stackLeak(JavaVMStackSOFTest02.java:10)
at com.lagou.unit.JavaVMStackSOFTest02.stackLeak(JavaVMStackSOFTest02.java:10)
……后续异常堆栈信息省略
```

对于不同版本的Java虚拟机和不同的操作系统， 栈容量最小值可能会有所限制， 这主要取决于操 作系统内存分页
大小。 譬如上述方法中的参数-Xss128k可以正常用于32位Windows系统下的JDK 6， 但 是如果用于64位Windows系
统下的JDK 11， 则会提示栈容量最小不能低于180K， 而在Linux下这个值则 可能是228K， 如果低于这个最小限
制， HotSpot虚拟器启动时会给出如下提示：

```
The Java thread stack size specified is too small. Specify at least 228k
```

我们继续验证第二种情况， 这次代码就显得有些“丑陋”了， 为了多占局部变量表空间， 不得不定义一长串变量，
具体如代码

```java
/**
 * @author zzm
 */
public class JavaVMStackSOF {
	private static int stackLength = 0;
	public static void test() {
        long unused1, unused2, unused3, unused4, unused5,
        unused6, unused7, unused8, unused9, unused10,
        unused11, unused12, unused13, unused14, unused15,
        unused16, unused17, unused18, unused19, unused20,
        unused21, unused22, unused23, unused24, unused25,
        unused26, unused27, unused28, unused29, unused30,
        unused31, unused32, unused33, unused34, unused35,
        unused36, unused37, unused38, unused39, unused40,
        unused41, unused42, unused43, unused44, unused45,
        unused46, unused47, unused48, unused49, unused50,
        unused51, unused52, unused53, unused54, unused55,
        unused56, unused57, unused58, unused59, unused60,
        unused61, unused62, unused63, unused64, unused65,
        unused66, unused67, unused68, unused69, unused70,
        unused71, unused72, unused73, unused74, unused75,
        unused76, unused77, unused78, unused79, unused80,
        unused81, unused82, unused83, unused84, unused85,
        unused86, unused87, unused88, unused89, unused90,
        unused91, unused92, unused93, unused94, unused95,
        unused96, unused97, unused98, unused99, unused100;
        stackLength ++;
        test();
        unused1 = unused2 = unused3 = unused4 = unused5 =
        unused6 = unused7 = unused8 = unused9 = unused10 =
        unused11 = unused12 = unused13 = unused14 = unused15 =
        unused16 = unused17 = unused18 = unused19 = unused20 =
        unused21 = unused22 = unused23 = unused24 = unused25 =
        unused26 = unused27 = unused28 = unused29 = unused30 =
        unused31 = unused32 = unused33 = unused34 = unused35 =
        unused36 = unused37 = unused38 = unused39 = unused40 =
        unused41 = unused42 = unused43 = unused44 = unused45 =
        unused46 = unused47 = unused48 = unused49 = unused50 =
        unused51 = unused52 = unused53 = unused54 = unused55 =
        unused56 = unused57 = unused58 = unused59 = unused60 =
        unused61 = unused62 = unused63 = unused64 = unused65 =
        unused66 = unused67 = unused68 = unused69 = unused70 =
        unused71 = unused72 = unused73 = unused74 = unused75 =
        unused76 = unused77 = unused78 = unused79 = unused80 =
        unused81 = unused82 = unused83 = unused84 = unused85 =
        unused86 = unused87 = unused88 = unused89 = unused90 =
        unused91 = unused92 = unused93 = unused94 = unused95 =
        unused96 = unused97 = unused98 = unused99 = unused100 = 0;
    } 
    
    public static void main(String[] args) {
		try {
			test();
		}catch (Error e){
			System.out.println("stack length:" + stackLength);
			throw e;
		}
	}
}
```

运行结果：

```shell
stack length:598
Exception in thread "main" java.lang.StackOverflowError
	at com.zuipin.yc.pos.db.JavaVMStackSOF.test(JavaVMStackSOF.java:33)
	at com.zuipin.yc.pos.db.JavaVMStackSOF.test(JavaVMStackSOF.java:34)
……后续异常堆栈信息省略  
```

实验结果表明： 无论是由于栈帧太大还是虚拟机栈容量太小， 当新的栈帧内存无法分配的时候， HotSpot虚拟机抛出的都是StackOverflowError异常。 可是如果在允许动态扩展栈容量大小的虚拟机 上， 相同代码则会导致不一样的情况。 譬如远古时代的Classic虚拟机， 这款虚拟机可以支持动态扩展 栈内存的容量， 在Windows上的JDK 1.0.2运行代码清单2-5的话（如果这时候要调整栈容量就应该改 用-oss参数了） ， 得到的结果是：

```shell
stack length:3716
java.lang.OutOfMemoryError
at org.fenixsoft.oom. JavaVMStackSOF.leak(JavaVMStackSOF.java:27)
at org.fenixsoft.oom. JavaVMStackSOF.leak(JavaVMStackSOF.java:28)
at org.fenixsoft.oom. JavaVMStackSOF.leak(JavaVMStackSOF.java:28)
……后续异常堆栈信息省略
```

可见相同的代码在Classic虚拟机中成功产生了`OutOfMemoryError`而不是`StackOverflowError`异常。 如果测试时不限于单线程， 通过不断建立线程的方式， 在`HotSpot`上也是可以产生内存溢出异常 的， 具体如下代码清单所示。  

但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系， 主要取决于操作系统本身的内存使用状态。 甚至可以说， 在这种情况下， 给每个线程的栈分配的内存越大， 反而越容易产生内存溢出异常。 原因其实不难理解， 操作系统分配给每个进程的内存是有限制的， 譬如32位Windows的单个进程 最大内存限制为2GB。
HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值， 那剩余的内存即为2GB（操作系统
限制） 减去最大堆容量， 再减去最大方法区容量， 由于程序计数器 消耗内存很小， 可以忽略掉， 如果把直接内
存和虚拟机进程本身耗费的内存也去掉的话， 剩下的内存 就由虚拟机栈和本地方法栈来分配了。 因此为每个线程
分配到的栈内存越大， 可以建立的线程数量自然就越少， 建立线程时就越容易把剩下的内存耗尽， 代码如下

**创建线程导致内存溢出异常**  

```java
/**
* VM Args： -Xss2M （这时候不妨设大些， 请在32位系统下运行）
*/
public class JavaVMStackOOM {
	private void dontStop() {
		while (true) {
		}
	} 
    public void stackLeakByThread() {
		while (true) {
			Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                	dontStop();
                }
		    });
			thread.start();
		}
	} 
    public static void main(String[] args) throws Throwable {
		JavaVMStackOOM oom = new JavaVMStackOOM();
		oom.stackLeakByThread();
	}
}
```

####  10.3 运行时常量池和方法区溢出

由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。前面曾经提到HotSpot从JDK7开始逐步“去永久代”的计划，并在JDK8中完全使用元空间来代替永久代的背景故事，在此我们就以测试代码来观察一下，使用“永久代”还是“元空间”来实现方法区，对程序有什么实际的影响。

 String::intern()是一个本地方法， 它的作用是如果字符串常量池中已经包含一个等于此String对象的 字符串， 则返回代表池中这个字符串的String对象的引用； 否则， 会将此String对象包含的字符串添加到常量池中， 并且返回此String对象的引用。 在JDK 6或更早之前的HotSpot虚拟机中， 常量池都是分配在永久代中， 我们可以通过

`-XX:PermSize`和`-XX:MaxPermSize`限制永久代的大小， 即可间接限制其中常量池的容量，

 具体实现如代码清单如下：

> 运行时常量池内存溢出

```java
/**
* VM Args： -XX:PermSize=6M -XX:MaxPermSize=6M
*/
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		// 使用Set保持着常量池引用， 避免Full GC回收常量池行为
		Set<String> set = new HashSet<String>();
		// 在short范围内足以让6MB的PermSize产生OOM了
		short i = 0;
		while (true) {
			set.add(String.valueOf(i++).intern());
		}
	}
}
```

运行结果：

```java
Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
at java.lang.String.intern(Native Method)
at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: 18)
```

从运行结果中可以看到，运行时常量池溢出时，在`OutOfMemoryError`异常后面跟随的提示信息是`PermGen space`，说明运行时常量池的确是属于方法区的一部分。

而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果， 无论是在JDK 7中继续使 

用`-XX：MaxPermSize`参数或者在JDK 8及以上版本使用`-XX:MaxMetaspaceSize`参数把方法区容量同 样限制在6MB， 也都不会重现JDK 6中的溢出异常， 循环将一直进行下去， 永不停歇。 出现这种变 化， 是因为自JDK 7起， 原本存放在永久代的字符串常量池被移至Java堆之中， 所以在JDK 7及以上版本， 限制方法区的容量对该测试用例来说是毫无意义的。 这时候使用`-Xmx`参数限制最大堆到6MB就能 够看到以下两种运行结果之一， 具体取决于哪里的对象分配时产生了溢出。

```java
// OOM异常一：
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
at java.base/java.lang.Integer.toString(Integer.java:440)
at java.base/java.lang.String.valueOf(String.java:3058)
at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:12)

// OOM异常二：
//根据Oracle官方文档，默认情况下，如果Java进程花费98%以上的时间执行GC，并且每次只有不到2%的堆被恢复，则JVM抛出
此错误
Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
at java.lang.Integer.toString(Integer.java:401)
at java.lang.String.valueOf(String.java:3099)
at com.lagou.unit.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:17)
```

> 方法区内存溢出

方法区的其他部分的内容， 方法区的主要职责是用于存放类型的相关信息， 如类名、 访问修饰符、 常量池、 字段描述、 方法描述等。 对于这部分区域的测试， 基本的思路是运行时产 生大量的类去填满方法区， 直到溢出为止。虽然直接使用Java SE API也可以动态产生类（如反射时的 `GeneratedConstructorAccessor`和动态代理等） ， 但在本次实验中操作起来比较麻烦。  

**借助CGLib使得方法区出现内存溢出异常**  

```java
/**
* VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M
*/
public class JavaMethodAreaOOM {
    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
            	public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy)
            throws ThrowException{
            	return proxy.invokeSuper(obj, args);
            }
            });
        enhancer.create();
      } 
    } 
    static class OOMObject {
    }
}
```

在JDK 6中的运行结果 ：

```
Caused by: java.lang.OutOfMemoryError: PermGen space
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)
at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
... 8 more
```

方法区溢出也是一种常见的内存溢出异常， 一个类如果要被垃圾收集器回收， 要达成的条件是比较苛刻的。 在经
常运行时生成大量动态类的应用场景里， 就应该特别关注这些类的回收状况。 这类场 景除了之前提到的程序使用
了CGLib字节码增强和动态语言外， 常见的还有： 大量JSP或动态产生JSP 文件的应用（JSP第一次运行时需要编译
为Java类） 、 基于OSGi的应用（即使是同一个类文件， 被不同 的加载器加载也会视为不同的类） 等。 在JDK 8以后， 永久代便完全退出了历史舞台， 元空间作为其替代者登场。 在默认设置下， 前面列举的那些正常的动态创建新类型的测试用例已经很难再迫使虚拟机产生方法区的溢出异常了。 不过 为了让使用者有预防实际应用里出现类似于上面代码的破坏性的操作， HotSpot还是提供了一 些参数作为元空间的防御措施， 主要包括：

-  `-XX:MaxMetaspaceSize`： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存 大小。

- `-XX:MetaspaceSize`： 指定元空间的初始空间大小， 以字节为单位， 达到该值就会触发垃圾收集 进行类型卸载，同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放 了很少的空间， 那么在不超过`-XX:MaxMetaspaceSize`（如果设置了的话） 的情况下， 适当提高该值。
- `-XX:MinMetaspaceFreeRatio`： 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比， 可 减少因为元空间不足导致的垃圾收集的频率。 类似的还有`-XX:MaxMetaspaceFreeRatio`， 用于控制最 大的元空间剩余容量的百分比。  

#### 10.4 直接内存溢出

直接内存（Direct Memory）的容量大小可通过`-XX:MaxDirectMemorySize`参数来指定，如果不去指定，则默认Java堆最大值（由-Xmx指定）一致，越过了`DirectByteBuffer`类直接通过反射获取Unsafe实例进行内存分配

（Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例， 体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能， 在JDK 10时才将Unsafe 的部分功能通过VarHandle开放给外部使用） ，因为虽然使用`DirectByteBuwer`分配内存也会抛出内存溢出异常， 但它抛出异常时并没有真正向操作系统申请分配内存， 而是通过计算得知内存无法分配就会 在代码里手动抛出溢出异常， 真正申请分配内存的方法是`Unsafe::allocateMemory()`  

```java
/**
* VM Args： -Xmx20M -XX:MaxDirectMemorySize=10M
*/
public class DirectMemoryOOM {
	private static final int _1MB = 1024 * 1024;
	public static void main(String[] args) throws Exception {
		Field unsafeField = Unsafe.class.getDeclaredFields()[0];
		unsafeField.setAccessible(true);
		Unsafe unsafe = (Unsafe) unsafeField.get(null);
		while (true) {
			unsafe.allocateMemory(_1MB);
		}
	}
}
```

运行结果：

```
Exception in thread "main" java.lang.OutOfMemoryError
	at sun.misc.Unsafe.allocateMemory(Native Method)
	at com.zuipin.yc.pos.db.DirectMemoryOOM.main(DirectMemoryOOM.java:21)
```

由直接内存导致的内存溢出， 一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常 情况， 如果发现内存溢出之后产生的Dump文件很小， 而程序中又直接或间接使用了 `DirectMemory`（典型的间接使用就是NIO） ，那就可以考虑重点检查一下直接内存方面的原因了。  



## 第三章 JVM加载机制详解





**参考资料**

[JVM操作数栈之栈顶缓存](https://www.wangt.cc/2021/08/jvm%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B9%8B%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98/)

